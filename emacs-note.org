#+TITLE:Emacs Note
#+AUTHOR: zhangjun
#+STARTUP: overview inlineimages shrink toc:2
#+CATEGORY: emacs
#+LANGUAGE: cn
* 目录
:PROPERTIES:
:TOC:      :include all :depth 2 :force (depth) :ignore (this) :local (depth)
:END:
:CONTENTS:
- [[#文件][文件]]
- [[#重复][重复]]
- [[#光标][光标]]
- [[#撤销][撤销]]
- [[#缓冲区][缓冲区]]
- [[#窗口][窗口]]
- [[#显示][显示]]
- [[#标记][标记]]
- [[#寄存器][寄存器]]
- [[#删除][删除]]
- [[#填充和注释][填充和注释]]
- [[#格式化和缩进][格式化和缩进]]
- [[#调换][调换]]
- [[#大小写][大小写]]
- [[#搜索][搜索]]
- [[#替换][替换]]
- [[#tab][Tab]]
- [[#定制][定制]]
- [[#tramp][tramp]]
- [[#projectile][projectile]]
- [[#treemacs][treemacs]]
- [[#go-目录树][go 目录树]]
- [[#vterm][vterm]]
- [[#termshell][term&shell]]
- [[#flycheck][flycheck]]
- [[#lsp][lsp]]
- [[#magit][magit]]
- [[#org][org]]
- [[#font][font]]
- [[#folding][folding]]
- [[#dired][dired]]
- [[#selectrum][selectrum]]
- [[#consult][consult]]
- [[#embark][embark]]
- [[#workflow][workflow]]
- [[#termshell][term&shell]]
- [[#image][image]]
- [[#web-开发][web 开发]]
- [[#不常用][不常用]]
- [[#footnotes][Footnotes]]
:END:

* 文件

|-----------+-------------------------+----------------------------------------------------------|
| 按键      | 函数                    | 功能                                                     |
|-----------+-------------------------+----------------------------------------------------------|
| C-x i     | insert-file             | 在当前位置插入文件                                       |
| C-x C-r   | find-file-read-only     | 只读打开文件(C-x r 是矩形编辑和寄存器的快捷键前缀)       |
| C-x C-f   | find-file               | 打开文件（C-x f 是设置 fill column）                     |
| C-x 4 C-f | find-file-other-window  | 在一个新窗口中打开文件                                   |
| C-x 4 f   | find-file-other-window  | 同上                                                     |
| C-x 5 C-f | find-file-other-frame   | 在一个新 frame 中打开文件                                |
| C-x 5 f   | find-file-other-frame   | 同上                                                     |
| C-x C-v   | find-alternate-file     | 打开一个文件，取代当前缓冲区。C-x v 是 VC 版本控制的前缀 |
| C-x C-s   | save-buffer             | 保存当前缓冲区文件                                       |
| C-x s     | save-some-buffers       | 保存某个缓冲区文件                                       |
| C-x C-w   | write-file              | 另存为新文件                                             |
| C-x C-c   | save-buffers-kill-emacs | 退出                                                     |
|-----------+-------------------------+----------------------------------------------------------|

=C-x C-f= 打开文件时，默认会加上当前目录，可以先删除该目录，也可以直接输入以下内容（忽略当前目录）：
1. 连续两个 // : 绝对路径；
2. ~: Home 路径；
3. 在 TRAMP 模式下，如果要打开本地文件，则可以连续三个 =///= ;

+ =C-c C-f /sudo::/path/to/file=: 以管理员权限编辑本地文件，:: 中的空格表示本地
+ =C-c C-f /sudo:user@host:filepath= 以管理员权限打开本地编辑远程文件
+ =C-c C-f /ssh:phil@remotehost#port:records/pizza-toppings.txt= 远程编辑文件

=save-some-buffers= 可以使用的快捷键：
+ n、y、q、!
+ C-r：view 模式查看要保存的 buffer；

* 重复

|-------------+------------------------+-------------------------------------------------|
| 按键        | 函数                   | 功能                                            |
|-------------+------------------------+-------------------------------------------------|
| M-N         | digit-argument         |                                                 |
| C-u         | universal-argument     |                                                 |
| C-x z       | repeat                 | 重复执行上一次名称，每多一个 z 字符就多执行一次 |
| C-x ESC ESC | repeat-complex-command |                                                 |
| M--CMD      |                        | 反向执行 CMD 一次                               |
| C-u-- CMD   |                        | 同上                                            |
| C-u--N CMD  |                        | 反向执行 CMD N 次                               |
|-------------+------------------------+-------------------------------------------------|

+ =C-x ESC ESC=: 适用于任何需要从 minibuff 读取输入的命令。
+ =univeral-argument= 与 ~digit-argument~ 的区别是：
  1. 它可以不带数字参数，表示重复 4 次;
  2. 除了表示重复次数，不带数字的 ~univeral-argument~ 还有改变命令行为的特殊含义;

* 光标

|---------+------------------------------+----------------------------------------|
| 按键    | 函数                         | 功能                                   |
|---------+------------------------------+----------------------------------------|
| C-f     | forward-char                 | 前进一个字符                           |
| C-b     | backward-char                | 后退一个字符                           |
| M-f     | forward-word                 | 前进一个单词                           |
| M-b     | backward-word                | 后退一个单词                           |
| c-a     | beginning-of-line            | 移到行首                               |
| C-e     | end-of-line                  | 移到行尾                               |
| M-a     | backward-sentence            | 移到句首                               |
| M-e     | forward-sentence             | 移到句尾                               |
| C-p     | previous-line                | 后退一行                               |
| C-n     | next-line                    | 前进一行                               |
| M-m     | back-to-indentation          | 移到当前行非空首字符                   |
| M-g M-g | goto-line                    | 跳转到指定行号                         |
| M-g g   | goto-line                    | 同上                                   |
| M-g c   | goto-char                    | 跳转到指定字符位置                     |
| C-v     | scroll-up-command            | 向下翻页                               |
| M-v     | scroll-down-command          | 向上翻页                               |
| C-M-v   |                              | 将临近的窗口中内容前翻                 |
| C-M-S-v |                              | 后翻                                   |
| C-M-f   | forward-sexp                 | 向前匹配光标右侧的记号(如字符串，括号) |
| C-M-b   | backward-sexp                | 向后匹配光标左侧的记号                 |
| C-M-a   | beginning-of-defun           | 向后移动光标到函数定义的开始           |
| C-M-e   | end-of-defun                 | 向前移动光标到函数定义的结束           |
| C-M-n   | forward-list                 | 按照括号向前移动                       |
| C-M-p   | backward-list                | 按照括号向后移动                       |
| C-M-u   | backward-up-list             | 跳转到当前括号的上一层次               |
| C-M-d   | down-list                    | 深入到当前行所在的下一级括号层次       |
| C-M-k   | kill-sexp                    | 删除当前 S 表达式                      |
| C-M-@   | mark-sexp                    | 标记当前 S 表达式                      |
| C-M-SPC |                              | 标记当前 S 表达式                      |
| C-M-h   | mark-defun                   | 标记函数                               |
| C-M-q   | prog-indent-sexp             | 格式化当前 S 表达式                    |
| M-<     | beginning-of-buffer          | 缓冲区头部                             |
| M->     | end-of-buffer                | 缓冲区尾部                             |
| M-r     | move-to-window-top-buttom    | 移到光标到中间行、屏幕头部、屏幕底部   |
| C-l     | recenter-top-bottom          | 将光标位置置于屏幕中间、头部、底部     |
| C-u C-l |                              | 将光标居中                             |
| C-M-l   | reposition-window            | 将窗口调整到最佳大小                   |
| M-.     | lsp-ui-peek-find-definitions | 跳转到定义位置                         |
| M-,     | xref-pop-marker-stack        | 跳转到上一次位置                       |
| M-?     | lsp-ui-peek-find-references  | 查找符号引用                           |
| M-g n   | next-problem                 |                                        |
| M-g p   | previous-problem             |                                        |
| C-x =   | what-cursor-position         | 显示光标位置                           |
| C-\     | toogle-input-method          | 切换输入法(M-\ 是删除光标附近的空格)   |
| M-g TAB | move-to-column               | 移动光标到当前行的第 N 列              |
|---------+------------------------------+----------------------------------------|

对于 =M-r= ，数字参数指定了光标的位置：
+ 数值参数是正值：从 window 头部开始的第 n 行；
+ 数字参数是负值：从 windown 尾部开始的第 n 行；
+ 特殊的 C-u -- 或 M-- M-r 则移动到 windown 尾部；

~avy~ 包提供快速跳转的功能：
+ M-g c :: 输入两个连续字符，然后在输入提示的标记，调转到对应的位置；
+ M-g l :: 输入每一行前面的标记，跳转到对应的行；

~goto-chg~ 包提供了快速跳转到上次修改位置的功能，可以作为 mark 标记跳转的补充：
+ C-< :: 跳转到上次修改的地方
+ C-> :: 反向跳转到上次修改的地方

* 撤销

|-------+------+----------|
| 按键  | 函数 | 功能     |
|-------+------+----------|
| C-_   | undo | 撤消操作 |
| C-/   |      | 同上     |
| C-x u |      | 同上     |
| C-x / |      | 同上     |
|-------+------+----------|

连续按 undo 时一直撤销，但是中间可以用非 undo 命令如 C-f 来终止，这样后续再 undo时，也会撤销刚才的 undo，达到
redo 的效果。

* 缓冲区

|---------+-------------------------------+----------------------------------------------------|
| 按键    | 函数                          | 功能                                               |
|---------+-------------------------------+----------------------------------------------------|
| c-x b   |                               | 选择当前窗口的缓冲区                               |
| C-x C-b | ibffer                        | 打开缓冲区列表                                     |
| C-x 4 b | switch-to-buffer-other-window | 选择当前窗口的缓冲区                               |
| C-x 5 b | switch-to-buffer-other-frame  | 选择当前窗口的缓冲区                               |
| C-x 5 0 | delete-frame                  | 关闭当前 frame                                     |
| C-x k   | kill-buffer                   |                                                    |
|         | kill-some-buffers             | 提示删除一些 buffers                               |
|         | eval-buffer                   | 执行当前缓冲区中的 lisp 语句                       |
|         | rename-buffer                 | 重命名 buffer，当要打开多个 eshell 或 info 时需要  |
|         | revert-buffer                 | 丢弃缓冲区自上次保存以来的所有改变                 |
| M-~     | not-modified                  | 清除当前缓冲区的修改标志(保存时不会提示保存该文件) |
| C-x C-q | read-only-mode                | 切换缓冲区为只读或者读写模式                       |
| C-q     | quoted-insert                 | quoted-insert                                      |
| M-/     | dabbrev-expand                | 自动提示扩充当前单词                               |
|---------+-------------------------------+----------------------------------------------------|

* 窗口

|---------+-------------------------------------+------------------------------------------------|
| 按键    | 函数                                | 功能                                           |
|---------+-------------------------------------+------------------------------------------------|
| C-x 0   |                                     | 关闭本窗口                                     |
| C-x 1   |                                     | 只留当前窗口                                   |
| C-x 2   |                                     | 垂直均分窗口                                   |
| C-x 3   |                                     | 水平均分窗口                                   |
| C-x o   |                                     | 切换到别的窗口                                 |
| C-x 4 o |                                     | 切换到别的窗口                                 |
| C-x 5 o |                                     | 切换到别的 frame                               |
| C-x 5 0 | delete-frame                        | deletes the selected frame                     |
| C-x 5 1 | delete-other-frames                 | deletes all other frames                       |
| C-x +   | balance-windows                     | 把所有窗口调整为同样大小                       |
| C-x -   | shrink-window-if-larger-than-buffer | 如果编辑缓冲区比窗口小就压缩窗口面积           |
| C-x <   | scroll-left                         | 向左滚动窗口                                   |
| C-x >   | scroll-right                        | 向右滚动窗口                                   |
| M-o     |                                     | 安装了 ace-window 后，可以通过窗口编号快速切换 |
|---------+-------------------------------------+------------------------------------------------|

=M-x winner-mode=: 启动 frame 窗口布局记忆机制，当一种窗口布局改变后可以用：
+ C-c  ← :: 命令恢复上一个布局
+ C-c  → :: 恢复下一个窗口布局

也可以使用寄存器来保存 frame 和 window 的布局：
+ C-c r f: 保存 frame 布局；
+ C-c r w：保存 window 布局；

自定义的、可以连续扩大和缩小窗口的快捷键（Shift-Control-xxx）：
#+begin_src lisp
(global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
(global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
(global-set-key (kbd "S-C-<down>") 'shrink-window)
(global-set-key (kbd "S-C-<up>") 'enlarge-window)
#+end_src

* 显示
 
|-----------------------------+---------------------------------+------------------------------------------|
| C-xnn                       | narrow-to-region                |                                          |
| C-xnw                       | widen                           |                                          |
| C-xnp                       | narrow-to-page                  |                                          |
| C-xnd                       | narrow-to-defun                 |                                          |
| C-xns                       | org-narrow-to-subtree           |                                          |
|-----------------------------+---------------------------------+------------------------------------------|
| C-x C-+、s - +              | text-scale-increase             | 放大当前显示的字体大小                   |
| C-x C--、s - -              | text-scale-decrease             | 缩小当前显示的字体大小                   |
| C-x C-0、s - 0              | text-scale-adjust               | 恢复当前显示的字体大小                   |
|-----------------------------+---------------------------------+------------------------------------------|
| M-x follow-mode             |                                 | 用两个 window 来连续显示一个 buffer 内容 |
| M-x view-buffer             |                                 |                                          |
|-----------------------------+---------------------------------+------------------------------------------|
| M-s h r regexp RET face RET | highlight-regexp                |                                          |
| M-s h u regexp RET          | unhighlight-regexp              |                                          |
| M-s h l regexp RET face RET | highlight-lines-matching-regexp |                                          |
| M-s h .                     | highlight-symbol-at-point       |                                          |
|-----------------------------+---------------------------------+------------------------------------------|
| M-x whitespace-mode         |                                 | 显示 buffer 的空白字符（包括换行符）     |
|-----------------------------+---------------------------------+------------------------------------------|

执行 =M-x follow-mode= 命令前，需要在一个 frame 中将一个 buffer 用 C-x 3 显示为两
个 window，然后才能滚动窗口 。

=M-x view-buffer= ：将当前 buffer 置为只读：
+ SPC：滚动
+ S-SPC：反向滚动
+ s：增量搜索
+ q：退出 view mode，返回以前的 buffer 位置
+ e：退出 view mode，但是保持当前位置；

按一次 C-x C-+ 后，可以一直按 C-+，这样就持续放大或缩小。

安装 symbol-overlay 包后，可以使用如下快捷键替换 M-s h r 的功能：
1. M-i: symbol-overlay-put
2. M-n：symbol-overlay-jump-next
3. M-p：symbol-overlay-jump-prev
4. <f7>：symbol-overlay-mode
5. <f8>：symbol-overlay-remove-all

* 标记

|-------------+-------------------------+---------------------------------------------------|
| 按键        | 函数                    | 功能                                              |
|-------------+-------------------------+---------------------------------------------------|
| C-SPC       | set-mark-command        | 在当前位置设置标记，并激活                        |
| C-@         |                         | 同上                                              |
| C-SPC C-SPC |                         | 设置标记，push 到 mark ring，不激活               |
| C-u C-SPC   |                         | 跳转到上一个标记环中的位置                        |
| C-u C-@     |                         | 同上                                              |
| C-x C-SPC   | pop-global-mark         | 使用 global mark ring 跳转到对应 buffer 中的位置  |
| C-x C-x     | exchange-point-and-mark | 交换当前光标位置到上一个标记位置                  |
| M-@         | mark-word               |                                                   |
| C-M-@       | mark-sexp               |                                                   |
| C-M-SPC     | mark-sexp               | 标记语法区域                                      |
| M-SPC       | just-one-space          | 只保留一个空格（M-\ 是删除光标附近所有空格和TAB） |
| C-x C-o     | delete-blank-lines      | 将多个空行合并为一个空行                          |
| M-h         | mark-paragraph          |                                                   |
| C-M-h       | mark-defun              |                                                   |
| M-=         | count-words-region      | 统计 region 内的字符数、行数等信息                |
| C-x h       | mark-whole-buffer       |                                                   |
|-------------+-------------------------+---------------------------------------------------|

在特定 buffer 中添加位置标记时，也会被自动添加到全局的标记环，使用它可以在多个
buffer 中跳转。

如果要临时跳转到其它位置，后续再返回当前位置，则通过 =C-SPC C-SPC= 做个快速标记，
后续再通过 =C-u C-SPC=返回是个不错的方案。

=Shift-Selection= ：按住 Shift 键的同时执行一些光标移动命令，如 =S-C-f S-C-n= 等，也
可以用来标记区域。

一般情况下，引起光标位置改变的操作，都会自动记录上一次位置，可以通过 =C-u C-SPC=
跳转到以前的历史位置。

=consult= 提供跳转到 mark 和 global mark 的功能：
+ M-g m: 跳转到 mark；
+ M-g k：跳转到全局 mark；

* 寄存器

Emacs 寄存器可以保存多种类型记录：
1. 光标位置记录；
2. frame 或 window 配置记录；
3. bookmark 记录；
4. rectangle 内容记录等；

|-------------------------+----------------------------------+------------------------------------------------------------|
| 按键                    | 函数                             | 功能                                                       |
|-------------------------+----------------------------------+------------------------------------------------------------|
| C-x r SPC r             | point-to-register                |                                                            |
| C-x r j r               | jump-to-register                 | Jump to the position and buffer saved in register r        |
|-------------------------+----------------------------------+------------------------------------------------------------|
| C-x r s r               | copy-to-register                 | Copy region into register r                                |
| C-x r i r               | insert-register                  | Insert text from register r                                |
|                         | M-x append-to-register <RET> r   | Append region to text in register r.                       |
|                         | M-x prepend-to-register <RET> r  | Prepend region to text in register r.                      |
|-------------------------+----------------------------------+------------------------------------------------------------|
| C-x r f r               | frameset-to-register             | 将当前 frame 配置保存到寄存器，后续可以恢复当前 frame 布局 |
| C-x r w r               | window-configuration-to-register | 将当前 window 配置保存到寄存器                             |
|-------------------------+----------------------------------+------------------------------------------------------------|
| C-x r d                 | delete-rectangle                 |                                                            |
| C-x r k                 | kill-rectangle                   |                                                            |
| C-x r M-w               | copy-rectangle-as-kill           |                                                            |
| C-x r y                 | yank-rectangle                   | 粘贴上一次删除的矩形区块，注意插入点位矩形的左上角         |
| C-x r o                 | open-rectangle                   | 用空格插入选择的矩形块，选择的内容右移                     |
| C-x r N                 | rectangle-number-lines           | 在选中的矩形块前插入序号                                   |
| C-x r c                 | clear-rectangle                  | 用空格填充选择的矩形块                                     |
| C-x r t                 | string-rectangle                 | 用指定字符填充选定的矩形区域                               |
| C-x r r                 |                                  | 拷贝矩形区域到寄存器中                                     |
| C-x r i r               |                                  | 使用寄存器 r 的内容                                        |
|-------------------------+----------------------------------+------------------------------------------------------------|
| C-x r m <RET>           |                                  | Set the bookmark for the visited file, at point.           |
| C-x r m <bookmark>      | bookmark-set                     | 在当前位置设置书签                                         |
| C-x r b                 | bookmark-jump                    | 跳转到书签                                                 |
|                         | M-x bookmark-rename              | 重命名书签                                                 |
|                         | M-x bookmard-delete              | 删除书签                                                   |
|                         | M-x bookmark-load                | 从指定文件中加载书签                                       |
|                         | M-x bookmark-insert              | 将书签指向的文件的内容插到光标处                           |
|                         | M-x bookmard-write               | 把书签全部保存到指定文件                                   |
|                         | M-x bookmark-save                | 将书签内容保存到文件，缺省为 ~/.emacs.d/bookmarks          |
| C-x r l                 | bookmark-menu-list               | 列出所有的书签                                             |
|-------------------------+----------------------------------+------------------------------------------------------------|
| M-x view-register RET r | 查看寄存器 r 的内容              |                                                            |
|-------------------------+----------------------------------+------------------------------------------------------------|

对于保存的 frame 或 window，可以使用 =C-x r j= 来恢复，从而实现类似于多 frame 切换且保持 window 布局的效果。

安装了 consult 包后，在进行寄存器和书签跳转前，可以自动预览和过滤。

* 删除

|---------------+-------------------------+----------------------------------------------|
| 按键          | 函数                    | 功能                                         |
|---------------+-------------------------+----------------------------------------------|
| C-d           | delete-char             | 删除插入点右边一个字符即光标所在的字符       |
| M-d           | kill-word               | 删除一个单词                                 |
| C-k           | kill-line               | 删除一行，注意：不删除行尾的换行符。         |
| M-BACKSPACE   |                         | 反向删除一个 word                            |
| M-k           | kill-sentence           | 删除一句                                     |
| M--C-k        |                         | 从行首删除到光标位置                         |
| C-w           | kill-region             | 删除标记区域                                 |
| M-w           | kill-region-save        | 复制标记区域                                 |
| C-y           | yank                    | 粘贴删除的内容                               |
| M-y           | yank-pop                | 循环粘贴粘贴板内容                           |
| C-M-k         | kill-sexp               | 向前剪切某个表达式，跨越的区域和 C-M-f 相同  |
| C-o           | open-line               | 插入一个空行                                 |
| C-x C-o       | delete-blank-line       | 删除光标附近的空行                           |
| M-^           | delete-indentation      | 将当前行和上一行连接                         |
| M-\           | delete-horizontal-sapce | 删除光标附近的空格(C-\ 切换输入法，C-/ 撤销) |
| M-SPC         | just-one-space          | 删除光标附近的空格，仅保留一个空格           |
| C-S-Backspace | kill-whole-line         | 删除当前行                                   |
| M-z Char      | zap-to-char             | 向前删除到 Char 字符                         |
|               | M-x prepend-to-buffer   | 将区域内容添加到缓冲区首                     |
|               | M-x append-to-buffer    |                                              |
|               | M-x copy-to-buffer      | 将内容拷贝到 buffer，删除 buffer 以前的内容  |
|               | M-x insert-buffer       | 将内容插入到 buffer 当前位置                 |
|               | M-x append-to-file      |                                              |
|---------------+-------------------------+----------------------------------------------|

M-- 和 M-z 反向命令前缀联合使用，可以实现快速的删除光标前面连续字符的功能。

embark find-file 时，可以使用 =C-M-Backspace= 删除上级目录。

* 填充和注释

如果一行内容超过了屏幕长度，Emacs 会自动将它作多行显示，这时每行行尾有一个箭头示
意。每行的原始内容称为 logical line，展示的多行称为 screen line，这种行为也称为
line wrapping or continuation（一般是在 window edge 开始 wrapping 的。）

如果想在行内容达到指定长度（而非默认的 window edge）自动添加回车，则可以使用
=Auto-Fill Mode= 。

Emacs 的命令，如 C-a、C-e 是按照 screen line 来移动的。如果想在 window edge 自动
line wrapping，但是 C-n、C-p 等按照 logical line 来移动，则可以使用 =Visual Line
Mode= 。

如果安装了 =visual-fill-column= ，则它提供的 =visual-fill-column-mode= 则结合了
Visual Line Mode 和 Auto-Fill Mode 的特性，可以在行内容达到指定长度（默认使用
fill-column，但如果设置了 visual-fill-column-width 则以它为准）后自动 line
wrapping，同时按照 logical line 来执行命令。

Auto-Fill 或 fill-paragraph 都是针对当前 paragraph 的，而 Emacs 使用缩进或至少两
个空行来识别 paragraph 的。如果一个 region 是多个缩进的 paragraph，但想把它们作
为一个 paragraph 来 fill，则需要使用 =fill-indiviual-paragraphs= 命令。

|---------+----------------------------------------+--------------------------------------|
| 按键    | 函数                                   | 功能                                 |
|---------+----------------------------------------+--------------------------------------|
| C-x f   | set-fill-column                        | 设置列边界                           |
| C-x ;   | comment-set-column                     | 设置 comment 列位置                  |
| M-q     | fill-paragraph                         | fill 段落                            |
|         | M-x *fill-individual-paragraphs*         | 对多个段落内容进行 Auto-Fill         |
|         | M-x auto-fill-mode                     | 自动 fill 模式，只对输入的段落有效。 |
|         | M-x refill-mode                        | 自动 fill 模式，对整个文件有效       |
|         | M-x display-fill-column-indicator-mode | 展示 fill-column 位置的边界线        |
| C-x C-; | comment-line                           |                                      |
| M-;     | comment-dwim                           |                                      |
|---------+----------------------------------------+--------------------------------------|

lisp 注释：如果是两个以上 ; 开头，则格式化的时候不移动注释位置。否则，按照
=comment-set-column= 的位置来移动注释。

* 格式化和缩进

|-----------+-------------------------+--------------------------------------------|
| 按键      | 函数                    | 功能                                       |
|-----------+-------------------------+--------------------------------------------|
| C-M-\     | indent-region           | 按照一定的代码风格格式化当前段落。         |
| C-x <TAB> | indent-rigidly          | 对选中区域使用左右箭头进行缩进             |
| M-^       |                         | 删除当前行的缩进，与上一行连接             |
| M-m       |                         | 跳转到当前行第一个缩进字符                 |
| C-j       |                         | 换行并缩进                                 |
| M-j       | default-indent-new-line |                                            |
| C-M-j     | indent-new-comment-line | 换行，如果位于注释中，则继续插入一个注释行 |
|-----------+-------------------------+--------------------------------------------|

* 调换
|---------+-----------------+------------------------------------|
| 按键    | 函数            | 功能                               |
|---------+-----------------+------------------------------------|
| C-t     | transport-chars | 将光标所在的字符和前一个字符对调   |
| M-t     | transport-words | 将光标所在 word 与前一个 word 对调 |
| C-M-t   | transport-sexps | Transpose two balanced expressions |
| C-x C-t | transport-lines | 将光标所在的行与上一行对调         |
|---------+-----------------+------------------------------------|

* 大小写
|---------+-----------------|
| 按键    | 函数            |
|---------+-----------------|
| M-u     | upcase-word     |
| M-l     | downcase-word   |
| M-c     | capitalize-word |
| C-x C-u | upcase-region   |
| C-x C-l | downcase-region |
|---------+-----------------|

* 搜索

+ C-s key isearch-forward 向前增量搜索
+ C-r key isearch-backward 反向搜索

Search 默认大小写不敏感，但如果搜索字符串中包含大写字母，则大小写敏感。

搜索过程中可以使用的快捷键：
+ C-s 查找下一个，ENTER 停止搜索
+ C-r 查找上一个，ENTER 停止搜索
+ C-g C-g isearch-abort 停止搜索
+ M-n、M-p 查找命令历史记录
+ C-y isearch-yank-kill 粘贴删除环中文本
+ M-y isearch-yank-pop 循环粘贴删除环中的文本
+ C-w isearch-yank-word-or-char 将光标所在位置到下一个标点符号或空格符间的文本添
  加到搜索字符串中
+ C-M-w isearch-yank-symbol-or-char appends the next character or symbol at
  point to the search string.
+ C-M-y isearch-yank-char appends the character after point to the search string
+ C-M-z isearch-yank-until-char appends to the search string everything from
  point until the next occurrence of a specified character
+ C-M-d isearch-del-char deletes the last character from the search string
+ M-s C-e isearch-yank-line 将光标所在的位置到行尾的内容添加到搜索字符串中
+ M-s o (isearch-occur): in incremental search invokes isearch-occur, which runs
  occur with the current search string
+ M-s h r (isearch-highlight-regexp): exit the search while leaving the matches
  highlighted
+ M-c 大小写敏感模式切换
+ M-r 正则匹配模式切换
+ M-% 切换到替换模式

搜索过程中，可以使用 =M-e（isearch-edit-string）= 编辑搜索字符串。

+ C-s ENTER search-forward :: 非增量搜索模式
+ C-r ENTER search-backward :: 进入反向非增量搜索模式

单词搜索模式：上面都是字符串完整匹配的搜索模式，如果要搜索多个字符串，同时忽略它
们之间的标点和换行符，则可以使用单词搜索模式：
+ M-s w 是单词搜索模式命令前缀：
+ M-s w isearch-forward-word 增量式单词搜索（在 C-s 或 C-r 命令中使用时切换到单
  词搜索模式）。
+ M-s w <RET> words <RET> 非增量式单词搜索
+ M-s w C-r words 反向增量式单词搜索
+ M-s w C-r <RET> words <RET> 反向非增量式单词搜索

标识符（symbol）搜索模式：按照 symbol 搜索(非常适合搜索代码的标识符和字符串）：
+ M-s . isearch-forward-symbol-at-point 搜索光标附近的 Symbol
+ M-s _ isearch-forward-symbol 按照 symbol 进行增量搜索
+ M-s _ RET symbol RET: Search forward for symbol, nonincrementally.
+ M-s _ C-r RET symbol RET: Search backward for symbol, nonincrementally.

按照正则表达式搜索：
+ C-M-s isearch-forward-regexp 向前增量式正则搜索
+ C-M-r isearch-backward-regexp 向后增量式正则搜索
+ C-M-s <RET> 向前非增量式正则搜索
+ C-M-r <RET> 向后非增量式正则搜索

Occur:
+ M-s o：Prompt for a regexp, and display a list showing each line in the buffer
  that con- tains a match for it
+ M-x multi-occur：和 occur 类似，但是可以选择多个 buffer 来进行搜索
+ M-x multi-occur-in-matching-buffers：先执行 buffer name 的 regexp，然后搜索

*Occur* Buffer 快捷键：
+ M-n、M-p：跳转到下一个或上一个匹配记录；
+ 回车、C-c C-c：在新窗口显示当前记录对应的文件；
+ o：在新窗口打开当前记录对应的文件，并移动光标到对应窗口；
+ C-o：在新窗口打开当前记录对应的文件，光标不移动；
+ e：编辑 Occur Buffer，然后 C-c C-c 保存；C-g 丢弃修改；
+ q: 终止 buffer；
+ c：clone Occur buffer；
+ r: rename buffer；
+ g：刷新 buffer；
+ h：显示帮助
+ C-c C-f: next-error-follow-minor-mode

安装 consult 后，可以通过 =M-s m= 来执行 =consult-multi-occur= ，利用它的自动补全功
能快速选择多个 buffer。

*Grep mode*:
+ M-x grep、M-x lgrep (local grep) Run grep asynchronously under Emacs, listing
  matching lines in the buffer named *grep*.
+ M-x grep-find、M-x find-grep、M-x rgrep (recursive grep) Run grep via find,
  and collect output in the *grep* buffer.
+ M-x zrgrep Run zgrep and collect output in the *grep* buffer.
+ M-x kill-grep Kill the running grep subprocess.

Your command need not simply run grep; you can use any shell command that
produces output in the same format. For instance, you can chain grep commands,
like this: =grep -nH -e foo *.el | grep bar | grep toto=

The output from grep goes in the *grep* buffer. You can find the corresponding
lines in the original files using M-g M-n, RET, and so forth, just like
compilation errors. See Section 24.2 [Compilation Mode], page 290, for detailed
description of commands and key bindings available in the *grep* buffer.

grep、occur、riggrep 都是继承自 compile mode，它们的 buffer 快捷键类似：
+ TAB             compilation-next-error
+ RET             compile-goto-error
+ C-o             compilation-display-error
+ <               beginning-of-buffer
+ >               end-of-buffer
+ ?               describe-mode
+ e               consult-compile-error
+ g               recompile
+ h               describe-mode
+ q               quit-window
+ C-c C-f         next-error-follow-minor-mode
+ C-c C-p         wgrep-change-to-wgrep-mode
+ n、p            上一个或下一个 error，会在其它窗口显示对应内容
+ M-n             compilation-next-error，不显示内容
+ M-p             compilation-previous-error，不显示内容
+ { 或 M-{             compilation-previous-file
+ } 或 M-}             compilation-next-file
+ C-c C-c         compile-goto-error
+ C-c C-k         kill-compilation

** deadgrep

<f5>：运行 deadgrep 搜索命令。搜索结果页面会列出所有匹配的文件和行，可以使用的快
捷键如下：

+ TAB：折叠当前文件匹配的内容
+ Enter：查看当前文件
+ o：在另一个 window 中查看光标位置的内容
+ n、p: 移动到下一行和上一行
+ N、P：移动到下一个匹配位置或上一个匹配位置
+ M-n、M-p：移动到下一个文件或上一个文件
+ g：刷新搜索内容
+ C-c C-k：kill deadgrep 使用的 rg 命令
+ q：关闭搜索结果 buffer

如果结果列表中文件比较多，可以使用 =M-g i (consult-imenu)= 展示文件列表，然后 C-m
跳转到对应的文件。

** projectile

+ C-c p s r (projectile-ripgrep)：需要当前或远程机器安装 rg 工具，结果显示在
  Ripgrep Mode buffer 中，快捷键与 compile mode 类似；
+ C-c p s g (projectile-grep)：使用 grep 在 project 范围内搜索；

** consult

+ M-s g: consult-grep
+ M-s G: consult-git-grep
+ M-s r: consult-ripgrep

对于上述搜索结果 Buffer，可以使用 embark-export 将其保存到一个特殊 buffer，然后
批量进行编辑（C-c C-p，切换到 wgrep 模式）。

consult 不支持 TRAMP 模式。

** dired

+ M-x find-grep-dired： 在指定目录执行 find 命令，然后 grep 文件内容；
+ M-x find-name-dired：在指定目录执行 find 命令，然后 grep 文件名；
+ M-x find-dired：直接执行 find 命令，结果在 dired 中显示；

dired 的 A 命令也可以递归搜索多个文件或目录。

* 替换

Replace 是从光标到 buffer 尾部，但如果有选中 Region，则只会替换该 Region 内容。
+ M-x replace-string 从光标到 buff 尾全局字符串替换
+ C-u M-x replace-string 同上，但是只在 word 边界处替换
+ M-x replace-regexp 从光标到 buff 尾全局符合正则表达式的字符串替换
+ M-% query-replace 交互替换
+ C-M-% query-regexp 交互式正则表达式替换

Query replace 过程中可以使用的快捷键：
+ e 编辑替换字符串
+ y 或 SPACE 确定替换当前位置，然后前进到下一个
+ n 或 DEL 不替换，前进到下一位置
+ . 在当前位置替换后退出查询替换操作
+ , 替换并显示替换情况(按空格或 y 继续，适合替换过程中先暂停的情况)
+ ! 对后面的内容全部替换，不再询问回车或 q 退出查找替换
+ ^ 返回上一次替换位置
+ u to undo the last replacement and go back to where that replacement was made.
+ U to undo all the replacements and go back to where the first replacement was made.

进入查找-替换模式后，按 C-r 进入递归编辑，或 C-w 删除此次内容并进入递归编辑模式：
+  C-M-x 退出递归编辑模式，返回到查找/替换模式 (exist)
+  C-M-c 同上(cancel)
+  C-]
  
  退出递归编辑和查找替换模式

其它替换命令：
+ M-x projectile-replace：在 project 级别搜索或替换文件。
+ M-x dired-do-find-regexp-and-replace：在 dired mode 上选中文件，按 Q 进行查询
  替换；
  
* Tab

|----------------------+----------------------------------------|
| 快捷键               | 功能                                   |
|----------------------+----------------------------------------|
| M-x white-space-mode | 显示当前 buffer 中的空白字符           |
| M-x tabify           | 将当前选中的内容中连续的空格转变为 tab |
| M-x untabify         | 将当前选中的内容中的 tab 转换为空格    |
|----------------------+----------------------------------------|

* 定制

Emacs 支持 5 种 Modify key：
+ Control：C-
+ Meta：M-
+ Super：s-
+ Alt：A-
+ Hyper：H-

例如： (global-set-key (kbd "s-n") #'next-line)

这些 keybinding 默认是不区分大小写的，例如 C-a 和 C-A 是一致的，但是在定义快捷键
时使用 Shift，例如：（global-set-key (kbd "C-S-n") #'next-line)

+ C-x 8 RET：插入 unicode 字符。

* tramp

+ C-c C-f /sudo::/path/to/file 以管理员权限编辑本地文件，:: 中的空格表示本地
+ C-c C-f /sudo:user@host:filepath 以管理员权限打开本地编辑远程文件
+ C-c C-f /ssh:phil@remotehost#port:records/pizza-toppings.txt 远程编辑文件

编辑远程文件时，tramp 自动将 auto-save 文件保存到本地。

tramp 一般和 projectile 联合使用，对于远程项目，如果不是 git 类型，则最好在项目
根目录创建一个空的 .projectile 文件，这样projectile 能正确识别项目根目录。另外，
为了加快查找效率，一般需要在远程机器上安装 fd 和 rg 命令。

可以打开 ssh 的 ControlPersist 特性，这样编辑远程多个文件更高效。
#+begin_src shell
Host *
  ControlMaster auto
  ControlPath ~/.ssh/master-%r@%h:%p  # 设置了 ControlPath 后才会复用连接.
  ControlPersist 120m
  ServerAliveInterval 10
  ServerAliveCountMax 60
  TCPKeepAlive no
  StrictHostKeyChecking no$ 
#+end_src

如果远程是 zsh，因为它一般会重新定义 PS1，则 tramp 会因为匹配不到 PS1 而 hang，
解决办法是在远程机器的 ~/.zprofile 文件头部（而非 ~/.zshrc，因为 zsh 会首先执
行~/.zprofile 文件） 添加如下内容：

#+begin_src bash
  ➜ multiarch cat ~/.zprofile if [ $TERM = "tramp" ]; then unset RPROMPT unset RPS1 unset PROMPT_COMMAND PS1="$ " unsetopt
  zle unsetopt rcs # Inhibit loading of further config files fi ➜ multiarch
#+end_src
+ 上面有效的前提是为 tramp 设置了如下变量：（setq tramp-terminal-type "tramp"）

* projectile

projectile 需要启用 cache，否则 TRAMP 有问题：
https://github.com/bbatsov/projectile/issues/835

如果远程文件不是 projectile 创建或修改的，则使用 =C-c p f= 有可能找不到新的文件，
这时可以 =M-x projectile-invalidate-cache= 清空 cache。

如果项目不是 git，则 projectile 会通过各种方式查找项目的 root 目录，为了提高性能，
可以在项目的 root 目录中创建一个 .projectile 文件。在项目的根目录下创建
.projectile 文件后，projectile 会无条件地将该目录作为项目的根目录，该文件可以定
义一些忽略模式，这样后续操作，如搜索文件、搜索内容时会忽略这些文件或目录：

#+begin_example
/tmp
/vendor
node_modules
node_modules/yaml
! node_modules/yaml/v1.1
#+end_example

为了加快远程文件查找，可以在远程机器添加 rg 和 fd 命令。

为了避免 preview TRAMP 书签时 hang，可以关闭 consult 的自动 preview 功能。

* treemacs

在 TRAMP 时，关闭 treemacs mode，否则文件读取性能会比较慢。treemacs 在每个 frame
里内嵌一个 buffer，显示某个 workspace 下的 project 列表。

可以编辑 treemacs workspace（每个 workspace 可以有多个 project），后续可以在不同
workspace 中切换。

+ M-0：显示并切换到 treemacs buffer，然后按 ? 可以显示 treemacs 的帮助快捷键，例
  如：
  + C-c C-w 开头的添加、删除、切换当前 workspace 的。
  + C-c C-p 开头的添加、删除、重命名 project 到当前 workspace。
  + n、l、p、u 等在 treemacs buffer 中移动光标的命令
  + o  开头的打开文件的命令
  + t 开头的 toggle 开关（特别是 tw 可以打开 treemacs buffer width 调整
  的开关）
+ M-x treemacs-add-project：在当前 workspace 中添加 project；
+ M-x treemacs-projectile： 从 projectile 项目列表中选择一个 project，然后添加到
  workspace
+ M-x treemacs-add-and-display-current-project：将当前的 project 添加到workspace
+ M-x treemacs-display-current-project-exclusively：只将当前 project 添加到当前
  project。

* go 目录树

对于依赖其它 github project module 的 go 项目, 默认通过 lsp 跳转时, 会将 mod
cache 中的目录自动添加 treemacs 中，这样会导致 treemacs 中添加太多单个目录。解决
办法如下：
1. 先将项目依赖的 module repo 克隆到本地目录；
2. 修改项目的 go.mod 文件，添加 replace 指令，将依赖的 module repo 指向刚才保存
   的本地目录；
   #+begin_src sh
     replace (
         github.com/go-admin-team/go-admin-core => /Users/zhangjun/codes/github/go-admin-core
         github.com/go-admin-team/go-admin-core/sdk =>
         /Users/zhangjun/codes/github/go-admin-core/sdk
     )
   #+end_src
3. 执行 M-x treemacs-display-current-project-exclusively 命令，创建一个新的
   Treemacs Workspace, 并将当前 project 加入到该 workspace;
4. 执行 M-x treemacs-add-project-to-workspace 将依赖 module repo 的本地目录添加到该 workspace;
5. 执行 M-x treemacs-rename-workspace 重命名当前 workspace 为有意义的名称；

* vterm

Emacs term 默认是非交互式 shell，不会调用 =~/.bash_profle= 文件，所以类似于 =PS1= 等
环境变量需要设置在 =~/.bashrc= 文件中。

在 ~/.zshrc 中添加如下内容，这样命令提示符追踪才能准确（复制内容时非常重要）：

#+begin_src bash
vterm_printf(){
    if [ -n "$TMUX" ]; then
        # Tell tmux to pass the escape sequences through
        # (Source: http://permalink.gmane.org/gmane.comp.terminal-emulators.tmux.user/1324)
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    else
        printf "\e]%s\e\\" "$1"
    fi
}

vterm_prompt_end() {
    vterm_printf "51;A$(whoami)@$(hostname):$(pwd)";
}

export PS1="[\u@\h \W]\$"

if [[ "$INSIDE_EMACS" = 'vterm' ]]; then
    alias clear='vterm_printf "51;Evterm-clear-scrollback";tput clear'
    setopt PROMPT_SUBST
    PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'
fi
#+end_src

对于远程服务器，也需要在 ~/.zshrc 文件中添加如上内容才行。

对于 bash，内容如下：
#+begin_src  bash
# https://github.com/akermu/emacs-libvterm#shell-side-configuration
vterm_printf(){
    if [ -n "$TMUX" ]; then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    else
        printf "\e]%s\e\\" "$1"
    fi
}

vterm_prompt_end(){
    vterm_printf "51;A$(whoami)@$(hostname):$(pwd)"
}

export PS1="[\u@\h \W]\$"

# 非 vterm 不设置 PS1，否则 emacs shell 等提示符显示异常。
if [[ "$INSIDE_EMACS" = 'vterm' ]]; then
    function clear(){
        vterm_printf "51;Evterm-clear-scrollback";
        tput clear;
    }
    PS1="\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ "
    PROMPT_COMMAND='echo -ne "\033]0;${HOSTNAME}:${PWD}\007"'
    PS1=$PS1'\[$(vterm_prompt_end)\]'
fi
#+end_src

在安装了 vterm-toggle package 后，可以快捷地在当前 buffer、bottom buffer 或 side
buffer 打开和关闭一个 vterm，定义的快捷键如下：

+ C-`：为当前 buffer 打开一个 vterm；
+ C-~：为当前 buffer 打开一个 vterm，并切换到当前工作目录；
+ s-n: 切换到下一个 vterm；
+ s-p：切换到前一个 vterm；

可以在打开的 term buffer 中按 Control-Return 快捷键，将自动切换到对应 buffer 的
目录。

如果打开多个 term，可以使用 M-x rename-buffer 命令重命名为有意义的名称， 或 M-x
rename-uniquely 这样便于后续参考。

+ C-c C-t :: 开启 copy mode 。当前 buffer 处于 readonly 状态，可以使用 emacs 各
  种指令进行操作，最后如果有选择的区域，按 Enter 进行拷贝，没有选中的区域则则拷
  贝最后一行。
+ C-c C-n 或者 C-c C-p :: 在命令行历史记录中跳转到上一个命令或下一个命令， 匹配
  的正则表达式为：
+ C-l :: clear 屏幕

M-x projectile-run-vterm 在 projectile 级别打开一个 vterm（多次执行该命令打开的
都是同一个 vterm buffer）

* term&shell

+ M-! cmd RET :: Run the shell command cmd and display the output (shell-command).
+ M-| cmd RET :: Run the shell command cmd with region contents as input;
  optionally replace the region with the output (shell-command-on-region).
+ M-& cmd RET :: Run the shell command cmd asynchronously, and display the
  output (async-shell-command).
+ M-x shell :: Run a subshell with input and output through an Emacs buffer. You
  can then give commands interactively.
+ M-x term :: Run a subshell with input and output through an Emacs buffer. You
  can then give commands interactively. Full terminal emulation is available.

A numeric argument to shell-command, e.g., =M-1 M-!=, causes it to insert terminal
output =into the current buffer= instead of a separate buffer.

To make multiple subshells, invoke =M-x shell= with a prefix argument (e.g., =C-u
M-x shell=). Then the command will read =a buffer name=, and create (or reuse) a
subshell in that buffer. You can also rename the *shell* buffer using =M-x
rename-uniquely=, then create a new *shell* buffer using plain M-x shell. Subshells
in different buffers run independently and in parallel.

Shell mode：不支持终端转义字符， =不建议使用= ：
+ 如果在 M-x shell 环境，则 emacs 设置环境变量 =INSIDE_EMACS= in the subshell to
    ‘version,comint’,这样可以针对性的初始化 shell。
+ C-c C-u、C-c C-w、C-c C-c、C-c C-\、C-c C-z
+ C-c C-o：删除上一个命令的输出
+ C-c C-s：将上一个命令的输出保存到指定 buffer
+ C-c C-r 或 C-M-l：将上一个命令的输出置到 window 的顶部；
+ M-p、M-n、M-r、C-c C-n、C-c C-p：命令历史记录
+ C-c C-l：在另一个 buffer 中展示当前 shell buffer 的历史记录； 然后可以搜索，
    回车确定；

Term mode： =建议使用= ，可以使用 top、vim 等：
+ C-c C-j：term-line-mode，切换到 Emacs 编辑模式，直到按回车键（将当前行发送给
    终端）。在粘贴拷贝的内容前，不能按回车。
+ C-c C-k：term-char-mode，切换到终端模式，输入的任何字符都会直接发送给终端
    （ 除了 C-c 字符外）。
+ C-c C-c: 向 shell 进程发送 C-c 命令；

C-c C-q: C-c C-q Toggle the page-at-a-time feature (term-pager-toggle). 在 line
和 char mode 都可以启用，当 term 输出超过一页时会暂停，按 SPACE 继续。

* flycheck

+ C-c ! v: 验证 buffer 使用的 checker（列表、二进制位置、优先级）
+ C-c ! C: 清理当前 buffer 的 error
+ C-c ! c: 检查当前 buffer 的 error
+ C-c ! n: 下一个语法检查错误
+ C-c ! p: 上一个语法检查错误
+ C-c ! l: 列出所有语法检查错误
+ C-c ! ?: 描述某一个 checker 的帮助信息
+ C-c ! s: 为当前 buffer 选择一个新的 checker
+ C-c ! x: 关闭某一个 checker
+ C-c ! e: 解释光标位置的错误

下面两个快捷键是自定义的:
+ M-g n：下一个错误
+ M-g p：上一个错误

如果安装了 lsp-mode 和 lsp-ui 则，lsp-ui 会使用 lsp-diagnose 来为 flycheck 自动
配置 lsp checker 并自动关闭其它 checker 。

+ M-x lsp-treemacs-errors-list: 使用 treemacs 列出所有语法检查错误;
+ M-x consult-flycheck (M-g f): 使用 consult 预览 flycheck 结果列表；

** 语言 checker

语言 checker 的名称惯例是 Language-Tool, 如 go-vet, go-build 等，一般对应外部可
执行程序（但也不是绝对的，如 go-vet 对应的可执行程序时 go, 但调用参数是 go vet）。

语言 checker 的可配置参数命名惯例是 flychecker-Language-xx, 如
flycheck-go-vet-executable.

** 为项目目录指定 checker

=flycheck-checker= 是目录本地变量（Directory Local Variables)，在项目根目录添
加这个变量配置后，flycheck 会使用指定的 checker 对相应 major mode 类型 buffer 进
行在线检查：
1. M-x add-dir-local-variable, 指定 major-mode 或目录；
2. Add directory-local variable：选择 flycheck-checker；
3. 为 flycheck-checker 指定变量值，如 go-vet；
   
emacs 自动在对应目录，如 ~/.emacs.d/ 添加 .dir-locals.el 文件，内容如下：
#+begin_src emacs-lisp
;;; Directory Local Variables
;;; For more information see (info "(emacs) Directory Variables")

((go-mode . ((flycheck-checker . go-vet))))
#+end_src

** python

python 的静态代码检查工具：
1. pep8、pycodestyle：PEP 8 是一种 Python 代码规范指南，可以参阅官网：
   https://www.python.org/dev/peps/pep-0008/ 已经重命名为 pycodestyle；
2. Pyflakes：一个用于检查 Python 源文件错误的简单程序。Pyflakes 分析程序并且检查
   各种错误。它通过解析源文件实现，无需导入它，因此在模块中使用是安全的，没有任
   何的副作用。
   + 不会检查代码风格
   + 由于它是单独检查各个文件，因此它也相当的快，当然检测范围也有一定的局限
3. Pylint：PyLint 是 Python 源代码分析器，可以分析 Python 代码中的错误，查找不符
   合代码风格标准和有潜在问题的代码，是一个可以用于验证多个文件的模块和包的工具。
   缺省情况下，PyLint 启用许多规则。它具有高度可配置性，从代码内部处理程序控制它。
   另外，编写插件添加到自己的检查中是可能的。
4. flake8 Flake8 是由 Python 官方发布的一款辅助检测 Python 代码是否规范的工具，
   相对于目前热度比较高的 Pylint 来说，Flake8 检查规则灵活，支持集成额外插件，扩
   展性强。Flake8 是对下面三个工具的封装：

  + PyFlakes：静态检查 Python 代码逻辑错误的工具。
  + Pep8： 静态检查 PEP8 编码风格的工具。
  + NedBatchelder’s McCabe ：静态分析 Python 代码复杂度的工具。

  不光对以上三个工具的封装，Flake8 还提供了扩展的开发接口。官方文档：
   https://pypi.python.org/pypi/flake8/
* lsp

lsp-rename 重新命令光标附近的 Symbol，如果是类名，则有可能自动重命名文件。java可
以使用 M-x lsp-install-server 命令来安装 jdtls 语言服务器，不需要手动安装了。

+ C-c a：执行 code action。
+ C-c r: 执行代码重构
+ C-c d：查看光标位置标识符的描述。（部分描述符需要先 C-a a 执行 import，然后才
  能看到描述）

+ lsp-treemacs-java-deps-list： 查看当前项目依赖
+ lsp-treemacs-symbols： 查看当前文件中的结构（符号）
+ lsp-treemacs-errors-list： 查看当前项目的错误列表。

调试 lsp server： ~M-x lsp-describe-session~

** python
   :LOGBOOK:
   CLOCK: [2021-03-13 Sat 18:37]--[2021-03-13 Sat 18:38] =>  0:01
   :END:

使用 pyenv 管理 python 环境和版本。如果项目位于虚拟环境中，则需要使用如下命令为
该环境安装 pyls，否则打开该项目的 python 文件后提示 pyls 启动失败：

``` bash
pip -q install ipython 'python-language-server[all]
```

为了让 python lsp 正确识别 project 的 python 版本，可以如下命令指定项目的 python 版本：

#+begin_src 
pyenv local 2.7.17
#+end_src

修改了项目的 python 版本后，需要重启 workspace 的 lsp server：

#+begin_src bash
M-x lsp-workspace-restart
#+end_src

可以在 ~*Message*~ buffer 中查看 LSP python 环境信息：

#+begin_quote
LSP :: Connected to [pyls:38780 status:starting].
LSP :: Configure pyls with environment: /Users/zhangjun/.pyenv/versions/2.7.17
LSP :: pyls:38780 initialized successfully
#+end_quote

为系统指定多个 python 版本：

#+begin_src bash
  pyenv global 3.8.13 27.17
#+end_src

不能自动补全：
+ 需要先用 ~pip~ 安装项目的依赖 ~package~ ，然后才能正确的自动补全。

** 调试 java jdtls

1. 可以查看 *lsp-log* buffer 的内容来定位报错的内容。
2. 升级 jdtls：C-u M-x lsp-install-server;
3. 报错：“jdt.ls-java-project does not exist”解决办法：删除
   ~/.emacs.d/workspace/.* 目录（隐藏目录）的内容。

如果 jdtls 启动失败，可以手动启动，查看日志：

``` bash ➜ .emacs.d git:(master) ✗
/Library/Java/JavaVirtualMachines/jdk-11.0.8.jdk/Contents/Home/bin/java
-Declipse.application=org.eclipse.jdt.ls.core.id1
-Dosgi.bundles.defaultStartLevel=4
-Declipse.product=org.eclipse.jdt.ls.core.product -Dlog.protocol=true
-Dlog.level=ALL -Xmx2G -XX:+UseG1GC -XX:+UseStringDeduplication
-javaagent:/Users/zhangjun/.m2/repository/org/projectlombok/lombok/1.18.6/lombok-1.18.6.jar
-jar
/Users/zhangjun/.emacs.d/.cache/lsp/eclipse.jdt.ls/plugins/org.eclipse.equinox.launcher_1.5.700.v20200207-2156.jar
-configuration /Users/zhangjun/.emacs.d/.cache/lsp/eclipse.jdt.ls/config_mac -data
/Users/zhangjun/.emacs.d/workspace/ --add-modules=ALL-SYSTEM --add-opens
java.base/java.util=ALL-UNNAMED --add-opens java.base/java.lang=ALL-UNNAMED ```

已知的问题是当前 workspace 中的部分 project 不存在导致启动失败，解决办法是清空
jdtls 的 -data 目录，然后重启 jdtls（M-x lsp-workspace-restart）：

```bash rm -rf ~/.emacs.d/workspace ```

* magit 
** Core

|---------+---------------------+----------------------------------------------------------------|
| C-x g   | magit-status        | 显示当前 buffer 对应的 git project status                      |
| C-x M-g | magit-dispatch      | 在小的 buffer window 中显示当前可以执行的 magit 快捷键命令。   |
| C-c M-g | magit-file-dispatch | 在小的 buffer window 中显示可以对当前 file 执行的 magit 命令。 |
|---------+---------------------+----------------------------------------------------------------|

nmagit 大部分命令都是单字符。在 magit-status buffer 中，执行的命令与当前光标所在
位置有关系。如在 Recent commits 下的某一个 commit 上时，SPACE 会显示该 commit的
内容，d 会显示前后两个 commit 的差别。

+ ? 或者 h： 根据光标所在的 buffer，显示对应的帮助菜单。如果对单个命令有疑问，也
  可以按 ? 来显示单命令的帮助。
+ $：显示 git process 的输出内容窗口，用于 debug, 用 q 关闭 debug 窗口
+ k：discard，当光标在 stage 位置时，丢弃 stage 和 worktree 中的内容。当在
  unstage 位置时，丢弃 worktree 的修改。当在untrack 位置时，会删除文件。
+ v：reverse a changing to worktree, 可以是 staged 或者 commited
+ s: 可以在 file 级别，也可以在 file 的 hunk 级别 stage 当前的改动
+ S: 将所有 unstaged 的变动提交到 Stage
+ u: 可以在 file 级别，也可以在 hunk 级别 unstage 当前的变动
+ U: unstage 所有的变动
+ g: 刷新 magit buffer

C-SPACE：给当前 file 或 hunk 标记，然后用 n、p 移动，最后可以用 s、u 操作标记的
区域。也可以用来在 Commit 或 log 列表中批量选中 commit，后续可以 apply 或 revert。
+ n/p: 在 section 或者 section 内部的 hunk 之间移动
+ M-n/M-p: 在 slibling section 之间移动
+ ^：移动到 section 的上一级(不是 u，u 的含义是 unstage)

+ TAB 展开当前 section
+ C-TAB：循环展示当前 section 和它的 children；而 TAB 是直接展开所有 children 的
  内容。
+ Enter：访问当前 section 的文件
+ 1-4：分别在当前 section 的 1-4 级之间之间展开
+ M 1-4: 分别在所有 section 的 1-4 级之间展开

+ !: 在当前工作目录或 git root 目录运行 git 或 shell 命令
+ C-g: 终止当前的 git 命令

C-c M-g: magit-file-dispatch 这个命令是针对当前文件的，可以：
1. stage、unstage、commit 当前文件；
2. Diff 和 diff 当前文件与其它 commit 或 master 的差别；其中 Diff 可以查看的更多样：
   1. dwim: 功能同 Diff range;
   2. Diff range: 提示输入比较的 commit ref，然后比较 workspace 当前文件与它的的差别；
   3. Diff paths: 提示输入两个路径的文件，然后显示他们的差别；
   4. Diff unstaged: 显示当前文件 unstaged changes；
   5. Diff staged：显示当前文件 staged changes；
   6. Diff worktree: 显示当前文件在 HEAD 和 working tree 之间的差别；
   7. Show commit: 显示某一个 commit 中当前文件的变更；
3. status(g): 整个 workspace 当前的状态（untracked、unstaged、staged 等状态文件）。
4. Log 和 log 查看当前文件的历史 commit；其中 Log 功能更丰富：
   1. current: 展示当前文件在当前分支的历史 commit；
   2. other：展示当前文件在其它分支或 commit 中的更新情况；
   3. head: 展示在 HEAD 对应分支中，当前文件的历史 commit 情况；
   4. Local Branchs: 展示在所有本地分支中，当前文件的 commit 情况；
   5. all branchs: 除了所有本地分支外，也包括远程分支，当前文件的 commit 情况；
   6. all reference: 展示所有分支中当前文件的 commit 情况；
** Branch

在 magit-log 页面，用蓝色表示当前所处的分支：

#+DOWNLOADED: screenshot @ 2021-01-16 18:53:19
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-16_18-53-19_screenshot.png]]

+ b: branch/revision :: checkout 本地或 remote 分支，如果是本地分支则切换过去，
  如果是 remote 分支，则 HEAD 会变成 detached（因为它不会为 remote 分支创建本地
  分支）。指定的分支必须存在，不创建新分支。
+ l: local branch :: checkout 本地或 remote 分支，如果是本地则切换过去。如果是远
  程，则本地创建创建一个同名的 track 分支（自动将本地分支 track remote分支）。如
  果是一个新的分支名，则会提示它的 starting-point，并自动 track 这个分支。
+ c: new branch :: Create and checkout BRANCH at branch or revision
  START-POINT. 创建并 checkout 到新的分支，如果当前分支有未提交的修改，则失败。
+ s: new spin-off :: Create new branch from the unpushed commits.

也可以在 log 或 commit list 的某一个 commit 上，执行分支命令，这时 checkout 指定
commit（bb），或创建新的 branch（bc）。

基于当前分支 checkout 一个新的分支，然后将旧的分支重置到上次和 upstream 同步的位
置。如果旧的分支没有 upstream 或者没有 unpush 的 commit，则老分支不变。这非常适
合在旧的 branch 上提交了一些 commit 但没有 push 到远程分支，想把这些改动转移到新
的特性分支的情况：老分支未 commit 的改动将体现在新的分支中。例如：当前是add-test
分支，并有一些 unstage 的修改，则 new spin-off 创建一个新的next-test-spinoff 分
支，并将 unstage 的内容保留到这个分支：

#+CAPTION: This is the caption for the next figure link (or table)
#+DOWNLOADED: screenshot @ 2021-01-16 19:40:11
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-16_19-40-11_screenshot.png]]

+ n: new branch :: Create BRANCH at branch or revision START-POINT. 创建分支但是
  不 checkout。
+ S: new spin-out :: 从 unpushed commits 位置创建新的分支，但是不 checkout，当前
  分支不变。如果当前分支有 uncommitted changes，则和 spin-off 类似，会 checkout这
  个新的分支。

小技巧：
1. 如果想基于历史 commit 创建一个 branch，可以先用 l l 展示当前分支 log，然后移
   动到目标 commit，再执行上述 branch 命令，则会提示以目标 commit 创建branch。

** Stash
+ z: stash :: 暂存当前的变更

git stash 使用流程：
+ git stash：保存当前工作进度，会把暂存区和工作区的改动保存起来。执行完这个命令
  后，再运行 git status 命令，就会发现当前是一个干净的工作区。
+ git stash save 'message...' 可以添加一些注释
+ git stash list：显示保存进度的列表。
+ git stash pop [–index] [stash_id]
+ git stash pop 恢复最新的进度到工作区。git 默认会把工作区和暂存区的改动都恢复到
  工作区。
+ git stash pop --index 恢复最新的进度到工作区和暂存区。（尝试将原来暂存区的改动
  还恢复到暂存区）
+ git stash pop stash@{1}恢复指定的进度到工作区。stash_id是通过git stash list命
  令得到的。通过git stash pop 命令恢复进度后，会删除当前进度。
+ git stash apply [–index] [stash_id] 除了不删除恢复的进度之外，其余和git stash
  pop 命令一样。
+ git stash drop [stash_id] 删除一个存储的进度。如果不指定stash_id，则默认删除最
  新的存储进度。
+ git stash clear 删除所有存储的进度。

#+DOWNLOADED: screenshot @ 2021-01-16 19:31:55
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-16_19-31-55_screenshot.png]]

magit 提供了 stash 和 snapshot 两种选择：https://emacs.stackexchange.com/a/22482

选择了 snapshot 后，magit 会创建一个 WIP commit，当前 working tree 内容不变。

Both the "stash" and "snapshot" variants create the same stash objects. The
difference is that when you create a snapshot, then =the stashed changes are not
removed= from the files in the working tree and/or the index. (Just like when you
take a snapshot of your friends having a good time - that doesn't cause them to
disappear either ;-)

This is intended as a backup mechanism of sorts. Say you are performing some
complicated refactoring and you just tested and the modified code still appears
to work but you are not done yet. Now would be a good time to create a snapshot,
so that you have something to go back to if you mess it up later.

Of course you could just create =a temporary "wip" commit=, right on the branch
you are working on, to accomplish the same. That's usually what I do.

And you can also automate the process of recording work-in-progress by enabling
the Wip modes. I do have these modes enabled as a safety net, but I still create
wip commits directly on the current branch or create a snapshot. Those are
easier to work with than the wip refs.

Note that Magit comes with its own stash implementation written in Elisp. That
was necessary to implement the snapshot variants and the worktree-only and
index-only stash variants. Git doesn't provide any of these variants.

** Commit

#+DOWNLOADED: screenshot @ 2021-02-09 11:25:23
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-02-09_11-25-23_screenshot.png]]

下面三个命令都是针对当前 HEAD 的：
+ a Amend: add the staged changes to HEAD and edit its commit message
+ e Extend: add the staged changes to HEAD without editing the commit message
+ w Reword: change the message of HEAD without adding the staged changes to it

下面三个命令是用当前 stage 的内容修改历史 commit（如果当前没有 stage 修改，则不
做任何操作）：
+ f Fixup: 选择一个历史 commit，然后将当前 stage 的修改合并进去，创建一个新的
  commit，commit msg 是 fixup! 前缀 + 选中的历史 commit msg；
+ s Squash：选择一个历史 commit，然后将当前 stage 的修改合并进去，创建一个新的
  commit，commit msg 是 squash! 前缀 +选中的历史 commit msg；
+ A Argument: 和 s Squash 类似，也是创建一个 squash commit，但是可以修改 squash
  message.

效果如下：
#+DOWNLOADED: screenshot @ 2021-02-09 13:10:31
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-02-09_13-10-31_screenshot.png]]

后续通过 r i (interactive) 进行 rebase 时候，如果打开 --autosquash 选项，则自动
对这些前缀 commit 执行对应的操作，例如：

#+DOWNLOADED: screenshot @ 2021-02-09 13:22:30
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-02-09_13-22-30_screenshot.png]]

git 使用 fixup! 或 squash! 后的 msg 来匹配历史 commit，然后加到相应 commit 的后
面：
#+DOWNLOADED: screenshot @ 2021-02-09 13:27:33
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-02-09_13-27-33_screenshot.png]]

上面的 Fixup、Squash 还有 Instance 版本，它们是将当前 stage 的内容自动 rebase 合
并到选择的历史 commit 中：
+ F：Instance fixup
+ S：Instance squash

在提交 msg 编辑界面：
+ C-c C-c：提交 commit
+ C-c C-k：cancel commit
+ M-p M-n：使用上一次或下一次的 commit message

** Diff

+ d: diff :: magit 模式是使用 Contex 模式来展示 diff 内容的。如果想 side-by-side
  则需要使用 ediff 模式。

** Ediff

M-x ediff: 选择两个文件进行比较。

打开 ediff 后，会在一个单独的  frame 显示一个 ediff control panel，使用  C-x 5 o
切换到该 frame。
+ ~：rotate ediff window 的布局；
+ |：在水平和垂直窗口布局间切换；
+ m：最大化 frame，特别适合水平布局的情况；

注：
1. 如果 ediff panel frame 没有在单独的 frame 中显示，则可使用 C-x b 切换到该
   buffer，然后使用 ? 来恢复。
2. 在 macos 系统下，需要将 ns-use-native-fullscreen 和
   ns-use-fullscreen-animation 设置为 nil，否则显示 ediff panel 时有问题。
3. which-key 可能会导致 ediff 的 gX 命令 hang，这时可以发送 USR2 信号来重新激活
   Emacs；
  
ediff 的 buffer 两种类型：
1. diff view：两个 buffer；
2. merge view：三个 buffer，第一个是 HEAD，第二个是 Index（Stage），第三个是
   Workspace；

在 magit 的 unstage、staged 区域的某个 diff 上：
1. 按 e：三窗口的 merge view。
2. 按 E：
    + u(show unstaged): 显示 unstaged 区域的文件与 HEAD 的差别。
    + i(show staged): 显示 stage 区域的文件与 HEAD 的差别。
    + w(show worktree)：显示 workspace文件与 HEAD 的差别。

   上面三个 show xxx，都是显示两个 buffer，A 为只读的 HEAD，b 为 unstage、staged
   或 worktree 中的文件，可以实现用 index 或 commit 的内容恢复 workspace 的修改。

    + E(dwim) 或者 s（staged）: 和上面直接按 e 类似，显示三窗口的 merge view。
    + c(show commit): 显示指定的 commit 的内容，两窗口 diff，指定一个 commit，然
      后 diff 它和上一次 commit 的差别。
    + r（show range）: 两窗口 diff，指定一个 commit，显示和当前 workspace 文件的
      差别，可以用于从历史恢复当前文件的变更。

三窗口 merge view：
 1. 第一个是 HEAD，只读状态；
 2. 第二个是 Index（Stage），可读写状态；
 3. 第三个是 Worktree，可读写状态。

可以修改 index 和 workspace 中的内容，实现将 workspace 内容（可以部分保存）保存
到 index 的效果，或者将 index 或 HEAD 的修改保存到 Workspace的效果。

~: 轮转 a、b、c buffer 中显示的内容，可以通过 buffer name 来判断各自显示的内容。

内容拷贝：
 + 两窗口的情况：a、b：a 表示把 a buffer diff 内容拷贝到 b，反之亦然。
 + 三窗口的情况：ab、ac、bc、cb：将前一个 buffer 当前 diff 区域拷贝到第二个 buffer。
   + a buffer 是 HEAD 的内容，不能修改，所以没有 ba、ca。

内容恢复：
 + ra、rb、rc：将对应 buffer 当前 diff 区域的内容恢复到该 buffer 最开始的内容。

+ C-x 5 o: 显示隐藏的 ediff panel；   
+ A/B/C：将 buffer a、b、c 设置为只读。
+ ?: 显示 ediff control panel 的帮助菜单，再次按 ? 会隐藏菜单。
+ n、p: 下一个或上一个 diff 位置。
+ j: 跳转到第一个 diff 位置。nj: n 为数字，表示跳转到第 n 个 diff 位置。
+ g a/b/c：将视图定位到 a/b/c buffer，这样后续该 buffer 中的 diff 总是处于可见区
  域的中间位置。
+ v、V：在当前 diff 位置上移或下移滚动，用于查看 diff 上下文信息。
+ h：切换 highlight 的风格：
   + 高亮所有 diff 区域；
   + 只高亮当前 diff 区域；
   + 使用 ascii 标识 diff 区域；
+ |：在水平和垂直方向上切换当前显示的方式。
+ </>：水平向左或向右滚动显示所有 buffer。
+ #f: 提示输出各 buffer 匹配的正则表达式，后续只显示匹配这些正则的 diff 区域。后
  续再次按 #f 取消选择。
+ #h：和 #f 类似，但是隐藏匹配的 diff 预期。后续再次按 #h 取消隐藏。
+ w a/b/c：将 buffer a、b、c 的内容保存到 *新的文件* 中。
+ wd：将 buffer b 和 c 的 diff 内容保存到新的文件中。
+ D: 在单独的 buffer 中显示指定的两个 buffer 的 diff 差别。
+ z：将当前 diff session 保存到后台，后续可以使用 M-x eregistry 命令查看暂存的
  session，非常适合有多个 ediff session 的情况；
+ q：终止 diff session。如果前面修改了 buffer 内容，会提示 save buffer。
+ !: 刷新 diff region，更新 diff 区域数量。

merge: 出现三个窗口，上面两个是冲突的版本，最下面是合并后的版本，可以将 A 或 B
的内容拷贝到 C，退出时提示保存，从而解决冲突。

#+DOWNLOADED: screenshot @ 2021-01-17 14:59:40
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_14-59-40_screenshot.png]]

magit-find-file：指定一个文件的 revision，可以查看该文件的内容。

** Fetch
+ fa：将 remote 仓库的所有 branch、tag 等拉取到本地；
** Push
P：push ::
+ p：push 到上游仓库
+ u：另一个上游仓库
** Log

可以按作者、Commit Msg、修改的内容、 文件等条件搜索历史：

#+DOWNLOADED: screenshot @ 2021-02-09 09:50:50
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-02-09_09-50-50_screenshot.png]]

可以查看当前 branch、指定 branch 或所有 branch 的 commit log：
+ SPACE: 显示当前 commit 的内容
+ DELETE：反向显示当前 commit 的内容
+ TAB：显示当前 commit 的内容
+ Enter：显示当前 commit 的内容，并切换到 commit buffer 中，按 q 可以关闭该
  buffer。
+ +: 显示更多 commit
+ -：显示更 少 commit
+ C-c C-n：移动到当前 commit 的 parent commit

L: 修改 log 显示的信息，如 singlestat、margin 等

小技巧：C-c M-g l 查看当前文件在 =当前分支= 的提交记录，这时按 l a 则可以看到当前
文件在 =所有分支= 的提交记录，然后就可以按 A 或 a 来 Apply 某个 commit 到当前分支。

** Merge

+ i: merge into: 将当前分支内容 merge 到其它分支，然后删除当前分支，并切换到
  merge into 的分支：
+ a: absorb 将另一个 branch merge 进当前 branch，然后删除那个分支。
+ s: squash merge 将指定分支的修改合并到当前分支，但是不创建 commit。注意：指定
  分支的多次 commit 内容会合并到当前 worktree，这样后续 commit 时，只会看到一次
  提交（而不管指定分支有多少次历史提交）。squash 的含义就是 merge 历史合并。在
  rebase 时也会使用。

如果只是想把其它分支的 commit 应用到当前分支，除了 merge 外，还可以使用
Appply（A 或 a） 或 Cherry（Y）。

为了得到线性、干净的历史提交记录，在将当前分支 merge 到主干前，可以先将它 rebase
到主干分支（期间还可以修改历史提交记录），这样后续在 merge 时会得到一个线性的提
交记录。

如果 merge 出现冲突，则 magit 会在 =magit-status（C-x g）= buffer 的 unstage 或
stage change section，而且行首有 unmerged 的字符串提示。可以在 unmerge 的位置按
k 丢弃 apply，或者按 e 使用 ediff 解决冲突。

** Cherry&Apply

+ Y （Cherries）: 先输入 HEAD，再输入 UPSTREAM，显示 HEAD 可以 cherry pick 到
UPSTREAM 的 commit 列表，然后使用 Aa、AA 或 a 来选择性的 apply 到当前 branch。所
以在使用 Y Cherries 命令之前， =需要先把当前 branch 切换到 UPSTREAM= ，这样后续才
能使用各种 Apply 命令。

+ A 或 a（Apply）: 是 Cherry 的快捷方式，用于将一个或多个 commit 快速应用到当前
  分支。

把 origin/Ark-v19.xR-zArm_fs 的部分 commit merge 到 origin/Ark-sm-kylin 分支中：
1. Cherry head: 选择提供 commit 的分支 origin/Ark-v19.xR-zArm_fs；
2. Cherry upstream 选择 Ark-sm-kylin；
3. 出现 commit cherry pick 列表：
+ 以 - 号开始的表示已经 pick 过；
+ 以 + 号开始的表示没有 pick 过； 

#+DOWNLOADED: screenshot @ 2021-01-21 16:53:33
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-21_16-53-33_screenshot.png]]

Cherry pick 冲突：

#+DOWNLOADED: screenshot @ 2021-01-21 17:02:38
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-21_17-02-38_screenshot.png]]

可以在 unmerge 的位置按 k 丢弃 apply，或者按 e 使用 ediff 解决冲突，然后按 A 继
续、忽略或终止。

基本上，可以在 Magit 的所有 commit 上执行 AA 或 Aa 或 a 命令来 Apply 这个 commit
到当前 branch。可以使用 C-SPC 来选中多个 commits，然后批量 Apply 或其它操作。

A a 或者 a 命令 (magit-cherry-apply)：
+ 将光标处或选中的 commit cherry apply 到当前分支，cherry apply 只是在 worktree
  中 appy changes， =并不 commit= ，后续 commit 时默认使用当前的 commit msg。如果
  选中了多个 commit，则直接 apply。
+ apply 有可能失败，这时 worktree 中会提示冲突，需要解决冲突并 stage 后按 A 继续；

A A：Pick(magit-cherry-copy)：
+ 将光标处的或者选中的多个 commit 拷贝到当前 branch，并提示 commit message，如果
  选中多个 commit，则直接 pick 它们，不提示编辑 commit msg。

#+DOWNLOADED: screenshot @ 2021-01-21 17:39:04
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-21_17-39-04_screenshot.png]]

下面这些命令都是将 commit apply 到 some branch，但是这些 commit 也会被从以前的分
支移除，以前分支和当前分支都可能出现冲突，需要解决完冲突后才能继续：
+ A h (magit-cherry-harvest)：将其它分支的 commit 合并到当前分支；
+ A d (magit-cherry-donate)：将当前分支的 comit 合并到其它分支；
+ A n (magit-cherry-spinout)：将当前分支的 commit 移动到一个新的分支，结束后当前
  分支不变；
+ A s (magit-cherry-spinoff): 将当前分支的 commit 移动到一个新的分支，结束后新的
  分支会被 checkout；

在 cherrk-pick 进行的过程中，可以执行如下命令：
+ A A (magit-sequence-continue) Resume the current cherry-pick or revert
  sequence.
+ A s (magit-sequence-skip) Skip the stopped at commit during a
  cherry-pick or revert sequence.
+ A a (magit-sequence-abort) Abort the current cherry-pick or revert
  sequence. This discards all changes made since the sequence started.
  
** Reset

#+DOWNLOADED: screenshot @ 2021-06-27 17:28:39
#+ATTR_HTML: :width 80% :align center
[[file:images/magit/2021-06-27_17-28-39_screenshot.png]]

+ m mixed：reset HEAD and index；
+ s soft：reset HEAD Only；
+ h hard：reset HEAD、index 和 files；
+ k keep：reset HEAD 和 index，但是保存 uncommitted 的 files；
+ i index only
+ w worktree：只 reset worktree 内容到指定 commit，HEAD 和 index 不变（即提交历
  史不变，已经 stage 但为 commit 的内容还在，但是 unstage 的内容会被 reset）；
+ f a file：reset file 到某个 commit；

mixed、soft reset HEAD 和 index 后，worktree 内容不变，即 reset 到的 commit 之后
的变更都还在 worktree 的 unstaged 区域中：

#+DOWNLOADED: screenshot @ 2021-06-27 17:35:06
#+ATTR_HTML: :width 80% :align center
[[file:images/magit/2021-06-27_17-35-06_screenshot.png]]

但是 hard 模式会将 HEAD、index 和 worktree 都 reset 到指定 commit 的状态（丢失
commit 以后的变更）。

先切换到要 reset 的分支，然后按 X (reset), 选择 h(reset 所有内容)，然后输入要
reset 到的 commit 位置：
 1. 指定 log 中显示的 7 位 commitid；
 2. 或者相对 commit，如 HEAD~1、HEAD~2；

 #+DOWNLOADED: screenshot @ 2021-01-16 19:08:16
 #+ATTR_HTML: :width 600 :align center
 [[file:images/magit/2021-01-16_19-08-16_screenshot.png]]
   
=全局快捷键 x（magit-reset-quickly）= 将当前分支的 HEAD 和 index reset 到指定的
Commit，该 Commit 之后的更新保存到 worktree 的 unstated 区域中：

#+DOWNLOADED: screenshot @ 2021-06-27 17:24:25
#+ATTR_HTML: :width 80% :align center
[[file:images/magit/2021-06-27_17-24-25_screenshot.png]]

** Revert

Revert 是创建一个相反的 Commit 来达到清除某次提交全部或部分变更的效果。

#+DOWNLOADED: screenshot @ 2021-06-27 16:53:50
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-06-27_16-53-50_screenshot.png]]

使用场景：
1. Revert 某个 Commit：在 log 中选择某个 commit，然后按 V V，提示 revert 某个
   commit，然后出现 commit 界面，自动填充 commit msg：Revert xxx;

#+DOWNLOADED: screenshot @ 2021-06-27 16:58:00
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-06-27_16-58-00_screenshot.png]]

2. Revert 某个 Commit 中的个别 change：可以在 commit 的 change list 中选择每个
   change，然后按 V v（Revert），自动创建一个可以 revert commit change 的修改，
   并 stage 保存到 worktree 中，提示 Revert 进行中，可以按 A 选择 action 来继续，
   终止； V v 有 =全局快捷键 v= 。

#+DOWNLOADED: screenshot @ 2021-06-27 16:59:54
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-06-27_16-59-54_screenshot.png]]

在 Revert 的过程中，由于会创建一个 Revert Change，可能与当前 worktree 的内容冲突，
这时 Revert 会暂停，需要手动解决冲突后继续（也可以按 A 然后选择 abort 中断
Revert 过程）：

#+DOWNLOADED: screenshot @ 2021-06-27 17:03:40
#+ATTR_HTML: :width 80% :align center
[[file:images/magit/2021-06-27_17-03-40_screenshot.png]]

解决冲突后，如果 stage 不为空，则 A A 会创建一个 Revert Commit。如果 stage 为空，
则说明没有需要 commit 的内容，这时可以 A a(abort) 或 A s(skip) 结束 Revert 过程。

** Rebase

以将 feature1 分支 rebase 到 master 为例：
1. git 把 feature1 分支里面的每个 commit 取消掉；
2. 把上面的操作临时保存成 patch 文件，存在 .git/rebase 目录下；
3. 把 feature1 分支 HEAD 指向最新的 master 分支；
4. 把上面保存的 patch 文件应用到 feature1 分支上；（由于以master分支为 base，应
   用的时候可能会有冲突）。后续，在 master 分支里 merge feature1 分支时，可以
   fast-forward，得到一个线性的提交历史。

rebase 冲突的时候会暂停，需要解决冲突后 git add，然后用 git rebase --continue 来
继续 rebase，如果要终止 rebase 则可以用 git rebase --abort 命令，这时分支会回到
rebase 前的状态。

rebase 还有另外两个用途：
1. 改写 commit 历史记录，如合并、删除多个 commit，修改 commit 的顺序、message 等。
   如 git rebase feature~5 feature，可以实现将 feature 分支的最近 5 次提交合并为
   一个。这可以使用 rebase 的interactive 模式来轻松实现。
2. 变基，如有三个分支 master、feature1、feature2，feature1 从 master checkout 出
   来，做了几次commit，然后 feature2 从 feature1 checkout 出来，也做了几次提交。
   如果希望将 feature2 的修改合并到 master，但是 feature1 不变的话，就需要变基了，
   即用命令 git rebase --onto master feature1 feature2；

rebase(r):
+ i: interactively: 交互式 rebase，在当前分支 commit history 中选择一个 commit，
  然后交互式的 rebase 从该 commit 开始的后续 commit。用于对当前提交的历史进行修
  改。
+ s: a subset： 选择一个 target newbase，然后在当前分支选择一个 START commit，将
  START 到 HEAD 的 commit 都 rebase 到 newbase 上。用于变基合并。

#+DOWNLOADED: screenshot @ 2021-01-17 15:28:02
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_15-28-02_screenshot.png]]

如果当前 commit 已经 push 到远程仓库，则后续执行 rebase 操作后，需要 force push
到原仓库，否则会 push 失败。

#+DOWNLOADED: screenshot @ 2021-02-09 11:59:55
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-02-09_11-59-55_screenshot.png]]

*** rebase on 其它分支-全部

按 r e，然后选择将当前分支 rebase 到的其它分支，这会将当前分支的所有 commit
rebase 到其它分支：

#+DOWNLOADED: screenshot @ 2021-02-07 09:50:40
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-02-07_09-50-40_screenshot.png]]

*** rebase on 其它分支-部分

使用 l a 命令，定位到要 rabase onto 的分支 commit，然后执行 r s（subset) 命令，
选择要 rebase onto 的分支 commit 位置：

#+DOWNLOADED: screenshot @ 2021-01-17 17:25:57
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_17-25-57_screenshot.png]]

选择当前分支的 start commit，例如 deb7，然后按 e，这时从这个 commit 开始到 HEAD
的 commit 都会rebase 到第一步的新 base 上：

#+DOWNLOADED: screenshot @ 2021-01-17 17:26:51
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_17-26-51_screenshot.png]]

出现了合并冲突：

#+DOWNLOADED: screenshot @ 2021-01-17 17:28:32
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_17-28-32_screenshot.png]]

解决冲突后，按 A r 继续 rebase：

#+DOWNLOADED: screenshot @ 2021-01-17 17:30:54
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_17-30-54_screenshot.png]]

结束后，可以看到当前分支已经 rebase 到了 master 分支上了：

#+DOWNLOADED: screenshot @ 2021-01-17 17:32:43
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_17-32-43_screenshot.png]]

*** rebase 修改历史

通过 rebase interactive 实现当前分支 commit 合并、删除、修改、msg 修改。

+ pick = use commit
+ reword = use commit, but edit the commit message
+ edit = use commit, but stop for amending
+ squash = use commit, but meld into previous commit
+ fixup = like "squash", but discard this commit's log message
+ exec = run command (the rest of the line) using shell

例如将下面红框中的 5 个 commit 合并为 2 两个： 
#+DOWNLOADED: screenshot @ 2021-01-17 17:44:57
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_17-44-57_screenshot.png]]

首先将光标移动到 start commit，然后输入 r i（interactive）：

#+DOWNLOADED: screenshot @ 2021-01-17 17:46:03
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_17-46-03_screenshot.png]]

修改历史 commit 的 rebase 方式（从旧到新），结束后 按 C-c C-c 开始：

#+DOWNLOADED: screenshot @ 2021-01-17 17:48:56
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_17-48-56_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-17 11:56:34
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_11-56-34_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-17 12:01:37
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_12-01-37_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-17 14:52:40
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_14-52-40_screenshot.png]]

rebase 过程中，对 pick 类型的 commit，都可以修改它的 commit message：

#+DOWNLOADED: screenshot @ 2021-01-17 14:56:05
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_14-56-05_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-17 15:14:59
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_15-14-59_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-17 15:19:29
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_15-19-29_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-17 15:21:13
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_15-21-13_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-17 15:21:40
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_15-21-40_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-17 15:22:50
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_15-22-50_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-17 15:24:06
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_15-24-06_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-17 15:11:54
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_15-11-54_screenshot.png]]

*** rebase: modify a commit

#+DOWNLOADED: screenshot @ 2021-01-17 15:49:25
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_15-49-25_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-17 15:52:40
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_15-52-40_screenshot.png]]

这时将 worktree 恢复到 7983d0b，可以修改文件和内容：

#+DOWNLOADED: screenshot @ 2021-01-17 15:58:48
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_15-58-48_screenshot.png]]

只有 stage 修改后的内容，才能继续 rebase。

如果按 e（edit），则出现当前分支到 HEAD 位置的 rebase 界面，可以调整后续 commit
的 rebase 行为。

#+DOWNLOADED: screenshot @ 2021-01-17 15:54:30
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_15-54-30_screenshot.png]]

*** rebase：remove commit

删除一个 commit 时，会将该 commit 后面的 commit 合并到前一个 commit，这时可能会
出现冲突：

#+DOWNLOADED: screenshot @ 2021-01-17 16:05:13
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_16-05-13_screenshot.png]]

提示合并冲突：

#+DOWNLOADED: screenshot @ 2021-01-17 16:07:54
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_16-07-54_screenshot.png]]

删除 commit 结束：

#+DOWNLOADED: screenshot @ 2021-01-17 16:10:14
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_16-10-14_screenshot.png]]

*** rebase: reword a commit

用于修改一个 commit 的 message，选择当前分支的某个 commit（ rebase 操作的都是当
前分支的 commit，其它分支的不行）：

#+DOWNLOADED: screenshot @ 2021-01-17 16:12:55
#+ATTR_HTML: :width 600 :align center
[[file:images/magit/2021-01-17_16-12-55_screenshot.png]]

修改的 commit 即以后的 commit 都会以 rebase 的方式重新提交。

** Refers
+ y：show refers，可以用来查看本地或 remote 所有的 branch、tags 等信息。在分支上，
  执行 k 命令可以用来删除 branch；

* org
** 参考
+ [[https://www.cnblogs.com/Open_Source/archive/2011/07/17/2108747.html][Org-mode 简明手册]]
** Global and local cycling

+ TAB：循环展开当前级别（光标必须位于 headerline）。
+ C-u TAB/Shift-TAB：循环展开所有级别。
+ C-u C-u TAB (org-set-startup-visibility): Switch back to the startup
  visibility of the buffer
+ C-u C-u C-u TAB (outline-show-all): Show all, including drawers.

+ C-c C-k (outline-show-branches): Expose all the headings of the subtree, but
  not their bodies. 会隐藏 parent headline 下的内容，非常适合查看子 headline 的
  内容。
+ C-c TAB (outline-show-children): Expose all direct children of the
  subtree. With a numeric prefix argument N, expose all children down to level
  N.

+ C-c C-x b (org-tree-to-indirect-buffer): Show the current subtree in an
  indirect buffer. With a numeric prefix argument N, go up to level N and then
  take that tree

** Initial visibility

#+begin_src org
#+STARTUP: overview
#+STARTUP: content
#+STARTUP: showall
#+STARTUP: showeverything
#+end_src
+ C-u TAB/Shift-TAB：循环展开所有级别（光标可以位于任意位置）
+ C-u C-u TAB (org-set-startup-visibility): Switch back to the startup
  visibility of the buffer
+ C-u C-u C-u TAB (outline-show-all): Show all, including drawers.

** Motion

+ C-c C-n/p：级别间移动
+ C-c C-u：移动到上一级
+ C-c C-f/b：相同级别间移动
+ C-c C-j (org-goto):
    1. TAB： 循环可见性
    2. /: regexp 搜索，M-g n、p 跳转到下一个和上一个匹配的位置；
    3. n/p: next/previous headline
    4. f/b: nex/previous headline same
    5. u: one level upstream
    6. 0 ... 9 : digit argument
    7. q: quit

** Structure editing
+ M-RET (org-meta-return) ::
插入 header、item 或 row。在当前行前插入（光标位于行首），将行拆分（光标位于行
中），在当前行尾插入（光标位于行尾）。如果光标没有位于 header、item 或 row，而是
普通行，则在当前行插入 headline 或 item。
+ C-u M-RET :: 在当前 subtree 后插入 headline。
+ C-u C-u M-RET :: 在 parent subtree 后插入 headline。
  
+ C-RET (org-insert-heading-respect-content) :: 在当前 subtree 后插入 headerline。
  （等效为 C-u M-RET）
+ M-S-RET (org-insert-todo-heading)  :: 在当前行插入一个 same level 的 TODO
  headline 或 item。
+ C-S-RET (org-insert-todo-heading-respect-content) :: 在当前 subtree 后面插入一
  个 TODO headline。

总结：如果要在当前行后插入 item 或 row，则必须使用 M-RET；C-RET 只是在当前
subtree 后插入一个 headerline；

+ TAB (org-cycle) :: 在插入 headline 或 item 的前导符号时，第一次按 TAB 是插入一
  个 child 层级，再按时插入一个 parent 级别，直到 top 级别。

下面两个命令，只操作当前 headerline 行：
+ M-LEFT (org-do-promote) :: Promote current heading by one level.
+ M-RIGHT (org-do-demote) :: Demote current heading by one level.

+ M-S-LEFT (org-promote-subtree) :: Promote the current subtree by one level.
+ M-S-RIGHT (org-demote-subtree) :: Demote the current subtree by one level.

+ M-UP (org-move-subtree-up) :: Move subtree up, i.e., swap with previous
  subtree of same level.
+ M-DOWN (org-move-subtree-down) :: Move subtree down, i.e., swap with next
  subtree of same level.

+ C-c @ (org-mark-subtree) :: 标记光标所在的 subtree。
+ C-c C-x C-w (org-cut-subtree) :: Kill subtree
+ C-c C-x M-w (org-copy-subtree) :: Copy subtree to kill ring
+ C-c C-x C-y (org-paste-subtree) :: Yank subtree from kill ring
+ C-y (org-yank) ::
+ C-c C-x c (org-clone-subtree-with-time-shift) ::
+ C-c C-w (org-refile) :: Refile entry or region to a different location. See
  Refile and Copy.
+ C-c ^ (org-sort) :: Sort same-level entries.

+ C-x n s (org-narrow-to-subtree) :: Narrow buffer to current subtree.
+ C-x n b (org-narrow-to-block) ::  Narrow buffer to current block.
+ C-x n w (widen) :: Widen buffer to remove narrowing.

+ C-c * (org-toggle-heading) :: Turn a normal line or plain list item into a
  headline
  
** Sparse Trees
Sparse tree 根据匹配条件，只显示匹配所在的 subtree 和它的父 tree headline；
+ C-c / (org-sparse-tree) :: This prompts for an extra key to select a
  sparse-tree creating command.
+ C-c / r or C-c / / (org-occur) :: Prompts for a regexp and shows a sparse tree
  with all matches.
+ M-g n or M-g M-n (next-error) :: Jump to the next sparse tree match in this
  buffer.
+ M-g p or M-g M-p (previous-error) :: Jump to the previous sparse tree match in
  this buffer.
** Plain Lists
+ TAB (org-cycle) :: Items can be folded just like headline levels.
+ M-RET (org-insert-heading) :: Insert new item at current level.
+ M-S-RET :: Insert a new item with a checkbox
+ C-c C-c :: If there is a checkbox (see Checkboxes) in the item line, toggle
  the state of the checkbox
+ C-c - :: Cycle the entire list level through the different =itemize/enumerate=
  bullets
+ C-c * :: Turn a plain list item into a =headline=
+ C-c C-* :: Turn the whole plain list into a subtree of the current heading.
+ S-LEFT / S-RIGHT :: This command also cycles =bullet styles= when point is in on
  the bullet or anywhere in an item line
+ C-c ^ :: Sort the plain list. Prompt for the sorting method: numerically,
  alphabetically, by time, or by custom function.
** Drawers

Sometimes you want to keep information associated with an entry, but you
normally do not want to see it. For this, Org mode has drawers.

You can also arrange for state change notes (see Tracking TODO state changes)
and clock times (see Clocking Work Time) to be stored in a ‘LOGBOOK’ drawer.

+ C-c C-x d :: org-insert-drawer, With an active region, this command puts the
  region inside the drawer
+ C-c C-x p :: set propertiy
+ C-u C-c C-x d :: org-insert-property-drawer
+ C-c C-z :: Add a time-stamped note to the ‘LOGBOOK’ drawer.

** Blocks

Org mode uses ‘#+BEGIN’ … ‘#+END’ blocks for various purposes from including
source code examples.These blocks can be folded and unfolded by pressing =TAB= in
the ‘#+BEGIN’ line.

C-c C-, : 插入各种 Block；

** Built-in Table Editor

Any line with ‘|’ as the first non-whitespace character is considered part of a
table. Moreover, a line starting with ‘|-’ is a horizontal rule.

+ C-c | (org-table-create-or-convert-from-region) :: Convert the active region
  to table
+ C-c C-c (org-table-align) :: Re-align the table without moving point.
+ TAB (org-table-next-field) :: Re-align the table, move to the next
  field. Creates a new row if necessary.
+ S-TAB (org-table-previous-field) :: Re-align, move to previous field.
+ C-c SPC (org-table-blank-field) :: Blank the field at point.
+ RET (org-table-next-row) :: Re-align the table and move down to next
  row. Creates a new row if necessary
+ M-a (org-table-beginning-of-field)
+ M-e (org-table-end-of-field)

+ M-LEFT (org-table-move-column-left) :: Move the current column left.
+ M-RIGHT (org-table-move-column-right) :: Move the current column right.
+ M-S-LEFT (org-table-delete-column) :: =Kill= the current column.
+ M-S-RIGHT (org-table-insert-column) :: Insert a new column at point
  position. Move the recent column and all cells to the right of this column to
  the right.

+ M-UP (org-table-move-row-up) :: Move the current row up.
+ M-DOWN (org-table-move-row-down) :: Move the current row down.
+ M-S-UP (org-table-kill-row) :: =Kill= the current row or horizontal line.
+ M-S-DOWN (org-table-insert-row) :: Insert a new row above the current
  row. With a prefix argument, the line is created below the current one.

+ C-c - (org-table-insert-hline) :: Insert a horizontal line below current
  row. With a prefix argument, the line is created above the current line.
+ C-c RET (org-table-hline-and-move) :: Insert a horizontal line below current
  row, and move point into the row below that line.
+ C-c ^ (org-table-sort-lines)

+ C-c C-x M-w (org-table-copy-region) :: Copy a rectangular region from a table
  to a special clipboard.
+ C-c C-x C-w (org-table-cut-region) :: Copy a rectangular region from a table
  to a special clipboard,
+ C-c C-x C-y (org-table-paste-rectangle) :: Paste a rectangular region into a
  table.
+ M-RET (org-table-wrap-region) :: Split the current field at point position and
  move the rest to the line below.

+ C-c ` (org-table-edit-field) :: Edit the current field in a separate window.
  + 当 org-table 因为 line word wrap 被隐藏时，C-c ` 命令就非常有用。
+ M-x org-table-export

+ C-c TAB (org-table-toggle-column-width) :: 根据 column width shrink 或 expand
  当前 column。
+ C-u C-c TAB (org-table-shrink) :: Shrink all columns with a column
  width. Expand the others.
+ C-u C-u C-c TAB (org-table-expand) :: Expand all columns.
|-----------+-------------------------+------------------------+-----------------------|
| <1>       | <10>                    | <20>                   | <5>                   |
|-----------+-------------------------+------------------------+-----------------------|
| asdfa     | asdfasdfasdfasdf        | asdfasdfasdfa          | adfasdfasdf           |
| asdfa     | asdfasdfas              | asdfasdfa              | asdfasdfa             |
|-----------+-------------------------+------------------------+-----------------------|
| asdfasdfa | asfasdfasdfasdfasdfasdf | asfasdfasdfasdfsadfasd | asdfasdfasdfasdfasdfa |

you can use =a special row= where the first field contains only =/=. The further
fields can either contain ‘<’ to indicate that this column should start a group,
‘>’ to indicate the end of a column, or ‘<>’ (no space between ‘<’ and ‘>’) to
make a column a group of its own.

| N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |
|---+-----+-----+-----+---------+------------|
| / |   < |     |   > |       < |          > |
| 1 |   1 |   1 |   1 |       1 |          1 |
| 2 |   4 |   8 |  16 |  1.4142 |     1.1892 |
| 3 |   9 |  27 |  81 |  1.7321 |     1.3161 |
|---+-----+-----+-----+---------+------------|
#+TBLFM: $2=$1^2::$3=$1^3::$4=$1^4::$5=sqrt($1)::$6=sqrt(sqrt(($1)))

** Link

格式： =[[LINK][DESCRIPTION]]= or =[[LINK]]=

To also edit the invisible LINK part, use =C-c C-l= with point on the link.

A link that does not look like a URL—i.e., does not start with a known scheme or
a file name— =refers to the current document= . You can follow it with =C-c C-o=
when point is on the link, or with a mouse click

Org provides several refinements to internal navigation within a document. Most
notably, a construct like ‘[[#my-custom-id]]’ specifically targets the entry with
the =‘CUSTOM_ID’= property set to ‘my-custom-id’. Also, an internal link looking
like =‘[[*Some section]]’= points to =a headline= with the name ‘Some section’25.

When the link does not belong to any of the cases above, Org looks for a
dedicated target: the same string in double angular brackets, like =‘<<My
Target>>’= .

If no dedicated target exists, the link tries to match the exact name of an
element within the buffer. Naming is done, unsurprisingly, with the ‘NAME’
keyword,

+ C-c l :: org-store-link
+ C-c C-l :: org-insert-link
+ C-u C-c C-l :: insert a link to a file.
+ C-c C-l (with point on existing link) :: edit the link and description parts
  of the link.
+ C-c C-o (org-open-at-point)
+ C-c % (org-mark-ring-push) :: Push the current position onto the Org mark
  ring, to be able to return easily.
+ C-c & (org-mark-ring-goto) :: Jump back to a recorded position. A position is
  recorded by the commands following internal links, and by C-c %.
+ C-c C-x C-n (org-next-link) / C-c C-x C-p (org-previous-link)
+ M-n、M-p：next/previous link
  
** ☞ TODO TODO-Items

+ C-c C-t (org-todo) :: Rotate the TODO state of the current item among
+ S-RIGHT/S-LEFT :: Select the following/preceding TODO state, similar to
  cycling （M-LEFT/M-RIGHT 是改变当前 headline 的级别）
+ S-M-RET (org-insert-todo-heading) :: Insert a new TODO entry below the current
  one.
+ C-u C-c C-t (org-todo) :: Prompt for a note and record a the time of the TODO
  state change

** [#A] Priorities

+ C-c , (org-priority) :: Set the priority of the current headline.
+ S-UP (org-priority-up) / S-DOWN (org-priority-down) ::

** Tags                                                                :Tags:

+ C-c C-q (org-set-tags-command) :: Enter new tags for the current headline
+ C-c C-c (org-set-tags-command) :: When point is in a headline, this does the
  same as C-c C-q.

** Properties and Columns
:PROPERTIES:
:CATEGORY: properties
:ID:       B5005843-6534-48C1-88B8-9C0D914B0091
:END:

+ C-c C-x p (org-set-property)
+ C-c C-c s (org-set-property)
+ C-c C-c d (org-delete-property)

** Dates and Times
:PROPERTIES:
:Effort:
:END:
:LOGBOOK:
CLOCK: [2021-05-28 Fri 20:02]--[2021-05-28 Fri 20:02] =>  0:00
CLOCK: [2021-05-28 Fri 19:59]--[2021-05-28 Fri 20:02] =>  0:03
CLOCK: [2021-05-24 Mon 19:19]--[2021-05-24 Mon 19:20] =>  0:01
CLOCK: [2021-05-24 Mon 19:19]--[2021-05-24 Mon 19:19] =>  0:00
CLOCK: [2021-05-18 Tue 10:21]--[2021-05-24 Mon 19:20] => 152:59
CLOCK: [2021-05-18 Tue 10:21]--[2021-05-18 Tue 10:21] =>  0:00
CLOCK: [2021-05-18 Tue 10:21]--[2021-05-18 Tue 10:21] =>  0:00
CLOCK: [2021-05-18 Tue 10:20]--[2021-05-18 Tue 10:20] =>  0:00
CLOCK: [2021-04-18 Sun 20:15]--[2021-04-18 Sun 20:15] =>  0:00
CLOCK: [2021-04-18 Sun 20:09]--[2021-04-18 Sun 20:09] =>  0:00
CLOCK: [2021-04-18 Sun 20:09]--[2021-04-18 Sun 20:09] =>  0:00
CLOCK: [2021-04-18 Sun 20:08]--[2021-04-18 Sun 20:09] =>  0:01
:END:

日期和时间戳类型：
+ Plain timestamp; Event; Appointment ::  <2006-11-02 Thu 20:00-22:00>
+ Timestamp with repeater interval ::   <2007-05-16 Wed 12:30 +1w>
+ Diary-style expression entries ::  =<%%(diary-float t 4 2)>=
+ Time/Date range ::  <2004-08-23 Mon>--<2004-08-26 Thu>
+ Inactive timestamp :: [2006-11-01 Wed]

+ C-c . (org-time-stamp) ::  当加 C-u 时插入带时间的日期；
+ C-c ! (org-time-stamp-inactive) :: 插入不活动的时间戳；
+ C-c C-c :: Normalize timestamp, insert or fix day name if missing or wrong.
+ C-c C-o (org-open-at-point) :: Access the agenda for the date given by the
  timestamp or -range at poin
+ S-LEFT (org-timestamp-down-day) / S-RIGHT (org-timestamp-up-day) :: Change
  date at point by one day.
+ S-UP (org-timestamp-up) / S-DOWN (org-timestamp-down) :: On the beginning or
  enclosing bracket of a timestamp, change its type.

+ DEADLINE: <2004-02-29 Sun>
+ SCHEDULED: <2004-12-25 Sat>
+ C-c C-d (org-deadline)
+ C-c C-s (org-schedule)
+ C-c / d (org-check-deadlines)
+ C-c / b (org-check-before-date)
+ C-c / a (org-check-after-date)

+ C-c C-x C-i (org-clock-in) :: Start the clock on the current item
  (clock-in). This inserts the ‘CLOCK’ keyword together with a timestamp wrapped
  into a ‘LOGBOOK’ drawer.
+ C-c C-x C-o (org-clock-out)
+ C-c C-x C-x (org-clock-in-last)
+ C-c C-c or C-c C-y (org-evaluate-time-range)
+ C-c C-x C-q (org-clock-cancel)
+ C-c C-x C-j (org-clock-goto)
+ C-c C-x C-d (org-clock-display)

+ C-c C-x e (org-set-effort) :: Set the effort estimate for the current
  + 默认的时间格式是 hh:mm 或 mm，也可以指定单位如 10min；
+ C-c C-x C-e (org-clock-modify-effort-estimate) :: Modify the effort estimate
  of the item currently being clocked.

+ C-c C-x 0 (org-timer-start)
+ C-c C-x ; (org-timer-set-timer)； 设置一个倒计时计时器，数字表示分钟，不支持单
  位后缀如 10min；设置前必须先关闭上面的 effort (使用 C-c C-x C-e 命令将 effort
  设置为空) 。
+ C-c C-x . (org-timer)
+ C-c C-x - (org-timer-item) 必须位于 timer list 中才有效；
+ C-c C-x , (org-timer-pause-or-continue)
+ C-c C-x _ (org-timer-stop)

** Refiling and Archiving

+ C-c C-w (org-refile) :: Refile the entry or region at point. 
+ C-u C-c C-w :: Use the refile interface to jump to a heading.
+ C-u C-u C-c C-w (org-refile-goto-last-stored) :: Jump to the location where
  org-refile last moved a tree to.
+ C-c M-w (org-refile-copy) :: Copying works like refiling, except that the
  original note is not deleted.

+ C-c C-x C-a (org-archive-subtree-default) :: Archive the current entry using
  the command specified in the variable org-archive-default-command.
+ C-c C-x C-s or short C-c $ (org-archive-subtree) :: Archive the subtree
  starting at point position to the location given by org-archive-location.
+ C-u C-c C-x C-s :: Check if any direct children of the current headline could
  be moved to the archive. check TODO
+ C-u C-u C-c C-x C-s :: As above, but check subtree for timestamps instead of
  TODO entries.
  
** Capture and Attachments
:PROPERTIES:
:ID:       B5005843-6534-48C1-88B8-9C0D914B0091
:END:

+ M-x org-capture (org-capture) :: Display the capture templates menu.
+ C-c C-c (org-capture-finalize) :: Once you have finished entering information
  into the capture buffer
+ C-c C-w (org-capture-refile) :: Finalize the capture process by refiling the
  note to a different place
+ C-c C-k (org-capture-kill) :: Abort the capture process and return to the
  previous state.

+ C-c C-a (org-attach) :: The dispatcher for commands related to the attachment
  system.

如果要插入 attachment link，则 C-c C-l 时选择 attachment 类型的 schema 即可，
org-mode 会自动补全文件路径。

** org-protocol

打开 mac 的脚本编辑器，输入如下内容：
#+begin_src bash
on open location this_URL
    do shell script "/Applications/Emacs.app/Contents/MacOS/bin/emacsclient \"" & this_URL & "\" && open -a Emacs"
end open location
#+end_src

存储为 “EmacsClient”，文件格式为 “应用程序”，保存到 /Applications 目录。

编辑 "/Applications/EmacsClient.app/Contents/Info.plist" 文件，在 plist->dict 中
添加如下内容：
#+begin_src xml
  <key>CFBundleURLTypes</key>
  <array>
    <dict>
      <key>CFBundleURLName</key>
      <string>org-protocol handler</string>
      <key>CFBundleURLSchemes</key>
      <array>
        <string>org-protocol</string>
      </array>
    </dict>
  </array>
#+end_src

执行如下命令：
#+begin_src bash
  xattr -r -d com.apple.quarantine /Applications/EmacsClient.app
#+end_src

双击 “/Applications" 中的 EmacsClient 应用程序，激活 org-proto 协议。

emacs 添加如下配置，确保开启了 emacs server：
#+begin_src lisp
(server-start)
(require 'org-protocol)
#+end_src

新建一个浏览器书签，Location 内容如下，然后点击该书签，确认 emacs 有反应：
#+begin_src javascript
  javascript:location.href='org-protocol://store-link?url='+encodeURIComponent(location.href)+'&title='+encodeURIComponent(document.title)
#+end_src

新建一个 capture template：
#+begin_src lisp
  (require 'org-protocol)
  (require 'org-capture)
  (add-to-list 'org-capture-templates
               '("c" "Capture" entry (file+headline "~/docs/inbox.org" "Capture")
                    "* %^{Title}\nDate: %U\nSource: %:annotation\nContent:\n%:initial"
                    :empty-lines 1))
#+end_src

新建一个浏览器书签，内容如下：
#+begin_src javascript
javascript:location.href='org-protocol://capture?template=c'+'&url='+encodeURIComponent(window.location.href)+'&title='+encodeURIComponent(document.title)+'&body='+encodeURIComponent(window.getSelection())
#+end_src

** Agenda Views
:PROPERTIES:
:CATEGORY: Work
:END:
The information to be shown is normally collected from all agenda files, the
files listed in the variable =org-agenda-files91=. If a directory is part of this
list, all files with the extension ‘.org’ in this directory are part of the
list.

+ C-c [ (org-agenda-file-to-front) :: Add current file to the list of agenda
  files. The file is added to the front of the list. If it was already in the
  list, it is moved to the front. With a prefix argument, file is added/moved to
  the end.
+ C-c ] (org-remove-file) :: Remove current file from the list of agenda files.
+ C-' / C-, (org-cycle-agenda-files) :: Cycle through agenda file list, visiting
  one file after the other.
+ M-x org-switchb :: Command to use an Iswitchb-like interface to switch to and
  between Org buffers.

Commands in the Agenda Buffer:
Motion
n (org-agenda-next-line) Next line (same as DOWN and C-n).
p (org-agenda-previous-line) Previous line (same as UP and C-p).

View/Go to Org file
+ SPC or mouse-3 (org-agenda-show-and-scroll-up) :: Display the original
  location of the item in another window. With a prefix argument, make sure that
  drawers stay folded.
+ L (org-agenda-recenter) :: Display original location and recenter that window.
+ TAB or mouse-2 (org-agenda-goto) :: Go to the original location of the item in
  another window.
+ RET (org-agenda-switch-to) :: Go to the original location of the item and
  delete other windows.
+ F (org-agenda-follow-mode) :: Toggle Follow mode. In Follow mode, as you move
  point through the agenda buffer, the other window always shows the
  corresponding location in the Org file. The initial setting for this mode in
  new agenda buffers can be set with the variable
  org-agenda-start-with-follow-mode.
+ C-c C-x b (org-agenda-tree-to-indirect-buffer) :: Display the entire subtree
  of the current item in an indirect buffer. With a numeric prefix argument N,
  go up to level N and then take that tree. If N is negative, go up that many
  levels. With a C-u prefix, do not remove the previously used indirect buffer.
+ C-c C-o (org-agenda-open-link) :: Follow a link in the entry. This offers a
  selection of any links in the text belonging to the referenced Org node. If
  there is only one link, follow it without a selection prompt.


Change display
+ A :: Interactively select another agenda view and append it to the current
  view.
+ o :: Delete other windows.
+ v d or short d (org-agenda-day-view) :: Switch to day view.
+ f (org-agenda-later) :: Go forward in time to display the span following the
  current one. For example, if the display covers a week, switch to the
  following week. With a prefix argument, repeat that many times.
+ b (org-agenda-earlier) :: Go backward in time to display earlier dates.
+ . (org-agenda-goto-today) :: Go to today.
+ j (org-agenda-goto-date) :: Prompt for a date and go there.
+ J (org-agenda-clock-goto) :: Go to the currently clocked-in task in the agenda
  buffer.
+ D (org-agenda-toggle-diary) :: Toggle the inclusion of diary entries. See
  Weekly/daily agenda.
+ G (org-agenda-toggle-time-grid) :: Toggle the time grid on and off. See also
  the variables org-agenda-use-time-grid and org-agenda-time-grid.
+ r (org-agenda-redo) / g :: Recreate the agenda buffer, 
+ C-x C-s or short s (org-save-all-org-buffers) :: Save all Org buffers in the
  current Emacs session, and also the locations of IDs.

Calendar commands
+ c (org-agenda-goto-calendar) :: Open the Emacs calendar and go to the date at point in the agenda.
+ c (org-calendar-goto-agenda) :: When in the calendar, compute and show the Org agenda for the date at point.
+ i (org-agenda-diary-entry) :: Insert a new entry into the diary,
+ M (org-agenda-phases-of-moon) :: Show the phases of the moon for the three months around current date.
+ S (org-agenda-sunrise-sunset) :: Show sunrise and sunset times. The geographical location must be set with calendar variables, see the documentation for the Emacs calendar.
+ C (org-agenda-convert-date) :: Convert the date at point into many other cultural and historic calendars.
+ H (org-agenda-holidays) :: Show holidays for three months around point date.

Exporting Agenda Views
+ C-x C-w (org-agenda-write) :: Write the agenda view to a file.

** Markup for Rich Contents
*** Paragraphs

Paragraphs are separated by at least =one empty line=. If you need to enforce a
line break within a paragraph, use =‘\\’= at the end of a line.

VERSE Block 可用于保持内容的格式(换行、缩进、空白符等)：
#+BEGIN_VERSE
 Great clouds overhead
 Tiny black birds rise and fall
 Snow covers Emacs

    ---AlexSchroeder
#+END_VERSE

如果要引用别人的内容，可以用 QUOTE Block 后续格式化输出时会自动在内容左右加缩进：
#+BEGIN_QUOTE
Everything should be made as simple as possible,
but not any simpler ---Albert Einstein
#+END_QUOTE

如果要居中内容，可以用 CENTER Block: 
#+BEGIN_CENTER
Everything should be made as simple as possible, \\
but not any simpler
#+END_CENTER

*** Emphasis and Monospace

You can make words ‘*bold*’, ‘/italic/’, ‘_underlined_’, ‘=verbatim=’ and
‘~code~’, and, if you must, ‘+strike-through+’. Text in the =code= and =verbatim=
string is =not= processed for Org specific syntax; it is exported verbatim.

To turn off fontification for marked up text, you can set
=org-fontify-emphasized-text= to nil. To narrow down the list of available markup
syntax, you can customize org-emphasis-alist.

+ C-c C-x \ (org-toggle-pretty-entities) :: This command formats sub- and
  superscripts in a WYSIWYM way.

*** Subscripts and Superscripts

=‘^’ and ‘_’= are used to indicate super- and subscripts. To increase the
readability of ASCII text, it is not necessary, but OK, to surround
multi-character sub- and superscripts with =curly braces=. For example

The radius of the sun is =R_sun = 6.96 x 10^8 m=.  On the other hand,
the radius of Alpha Centauri is =R_{Alpha Centauri} = 1.28 x R_{sun}=.

You can set =org-use-sub-superscripts= in a file using the export option ‘^:’ (see
Export Settings). For example, ‘#+OPTIONS: ^:{}’ sets org-use-sub-superscripts
to {} and limits super- and subscripts to the curly bracket notation.

如果将 org-use-sub-superscripts 设置为 nil 或者在文件中配置 #+OPTIONS: ^:{} ，则
orgmode 将只使用 ^{} 或者 _{} 语法来表示上标或下标

+ C-c C-x \ (org-toggle-pretty-entities) :: This command formats sub- and
  superscripts in a WYSIWYM way.

*** Special Symbols
-- --- ...
You can use LaTeX-like syntax to insert special symbols—named entities—like ‘\alpha’
to indicate the Greek letter, or ‘\to’ to indicate an arrow.

Completion for these symbols is available, just type =‘\’= and maybe a few
letters, and press =M-TAB= to see possible completions. If you need such a symbol
inside a word, terminate it with =a pair of curly brackets=. For example

#+begin_example
Pro tip: Given a circle \Gamma of diameter d, the length of its
circumference is \pi{}d.
#+end_example

A large number of entities is provided, with names taken from both HTML and
LaTeX; you can comfortably browse the complete list from a dedicated buffer
using the command =org-entities-help=.

*** Literal Examples

You can include literal examples that should =not be subjected to markup=. Such
examples are typeset in =monospace=, so this is well suited for source code and
similar examples.

#+BEGIN_EXAMPLE
  Some example from a text file.
#+END_EXAMPLE

There is one limitation, however. You must insert =a comma right before lines
starting with either ‘*’, ‘,*’, ‘#+’ or ‘,#+’=, as those may be interpreted as
outlines nodes or some other special syntax. Org transparently strips these
additional commas whenever it accesses the contents of the block.

#+BEGIN_EXAMPLE
,* I am no real headline
#+END_EXAMPLE

For simplicity when using small examples, you can also start the example lines
with =a colon followed by a space=. There may also be additional whitespace before
the colon:

Here is an example
   : Some example from a text file.

对于代码，可以使用 SRC Block 并指定源码类型：

#+BEGIN_SRC emacs-lisp
  (defun org-xor (a b)
    "Exclusive or."
    (if a (not b) b))
 #+END_SRC

在 SRC 行最后可以加 -n 参数，表示对源码行加行号，-n 20 标识行号的开始序号，+n 表
示继续 follow 上一个 SRC Block 加行号，+n 10 表示在上一个 SRC Block 的基础上加10
再标记：

#+BEGIN_SRC emacs-lisp -n 20
  ;; This exports with line number 20.
  (message "This is line 21")
#+END_SRC

#+BEGIN_SRC emacs-lisp +n 10
  ;; This is listed as line 31.
  (message "This is line 32")
#+END_SRC

In literal examples, Org interprets strings like ~‘(ref:name)’~ as labels, and use
them as targets for special hyperlinks like ~‘[[(name)]]’~

You can also add a =‘-r’= switch which removes the labels from the source
code116. With the =‘-n’= switch, links to these references are labeled by the line
numbers from the code listing.

However, you can use the ‘-i’ switch to also preserve the global indentation, if
it does matter.

#+BEGIN_SRC emacs-lisp -r -n -i
  (save-excursion                 (ref:sc)
     (goto-char (point-min))      (ref:jump)
#+END_SRC

In line [[(sc)]] we remember the current position. [[(jump)][Line (jump)]] jumps to point-min.

If the syntax for the label format conflicts with the language syntax, use a
=‘-l’= switch to change the format, for example

#+BEGIN_SRC go -n -r -l "((%s))"
  package main
  
  import "os"
  
  func main() {
      os.Exit(1)
  }
#+END_SRC

如果 Example 或 SRC 内如比较长，可以用 =C-c ' (org-edit-special)= 来在另一个buffer
中编辑内容。编辑结束后用 =C-c '= 来保存， =C-c C-k= 来关闭。

在这个 buffer 中，可以用 =C-c l(org-store-link)= 来为当前光标行添加 ref label, 然后
用 =C-c C-l= 插入这个 ref 的链接。这样不需要自己手动在代码中添加引用标记。

*** Images

An image is a link to an image file118 that =does not have a description part=,
for example:

#+CAPTION: This is the caption for the next table (or link)
#+ATTR_HTML: :width 600px
[[/Users/zhangjun/Downloads/F6BAB117-D04D-4A78-B144-A15BFEDE5981.png]]

If you wish to define a =caption= for the image (see Captions) and maybe =a label=
for internal cross references (see Internal Links), make sure that the link is
on a line by itself and precede it with =‘CAPTION’ and ‘NAME’= keywords as
follows:

#+begin_example
#+CAPTION: This is the caption for the next figure link (or table)
#+NAME:   fig:SED-HR4049
[[./img/a.jpg]]
#+end_example

添加 CAPTION 后，在 html export 后，会在图片的下方显示 Figure 1: xxxx 的标题。

Such images can be displayed within the buffer with the following command:
+ C-c C-x C-v (org-toggle-inline-images)
+ C-c C-x C-M-v (org-redisplay-inline-images)

可以使用 #+ATTR_HTML :width 100 来指定照片显示的宽度:
#+ATTR_HTML: :alt my picture :width 300px
[[~/Pictures/IMG_5648.jpeg]]

Toggle the inline display of linked images. When called with a prefix argument,
also display images that =do have= a link description. You can ask for inline
images to be displayed at startup by configuring the variable
=org-startup-with-inline-images=

The variable org-startup-with-inline-images can be set within a buffer with the
=‘STARTUP’= options =‘inlineimages’= and =‘noinlineimages’=.

*** Captions

You can assign a caption to a specific part of a document by inserting a
‘CAPTION’ keyword =immediately= before it:

#+begin_example
#+CAPTION: This is the caption for the next table (or link)
| ... | ... |
|-----+-----|
#+end_example

Optionally, the caption can take the form: #+CAPTION[Short caption]: Longer caption.

#+begin_example
#+CAPTION[Short caption]: Longer caption.
#+end_example

Even though images and tables are prominent examples of captioned structures,
the same caption mechanism can apply to =many others= —e.g., LaTeX equations,
source code blocks. Depending on the export back-end, those may or may not be
handled.

*** Horizontal Rules

A line consisting of only dashes, and =at least 5= of them, is exported as a
horizontal line.

*** Creating Footnotes

A footnote is started by a footnote marker in =square brackets in column 0=, no
indentation allowed. It ends at the next footnote definition, headline, or after
=two consecutive= empty lines. The footnote reference is simply the marker in
square brackets, inside text. Markers always start with =‘fn:’=. For example:

#+begin_example
The Org homepage[fn:1] now looks a lot better than it used to.
...
[fn:1] The link is: https://orgmode.org
#+end_example

Org mode extends the number-based syntax to =named footnotes= and optional inline
definition. Here are the valid references:

#+begin_example
‘[fn:NAME]’
A named footnote reference, where NAME is a unique label word, or, for simplicity of automatic creation, a number.

‘[fn:: This is the inline definition of this footnote]’
An anonymous footnote where the definition is given directly at the reference point.

‘[fn:NAME: a definition]’
An inline definition of a footnote, which also specifies a name for the note. 
#+end_example

+ C-c C-x f :: The footnote action command. 光标位于居中时，插入 inline footnote.
+ C-c C-c :: If point is on a footnote reference, jump to the definition. If it
  is at the definition, jump back to the reference.
+ C-c C-o  :: Footnote labels are also links to the corresponding definition or
  reference

** Exporting

Users can install libraries for additional formats from the Emacs packaging
system. For easy discovery, these packages have a common naming scheme: =ox-NAME=,
where NAME is a format.

Org only loads back-ends for the following formats by default: =ASCII, HTML,
iCalendar, LaTeX, and ODT=. Additional back-ends can be loaded in either of two
ways: by configuring the =org-export-backends= variable, or by requiring libraries
in the Emacs init file. For example, to load the Markdown back-end, add this to
your Emacs config:
  : (require 'ox-md)

+ C-c C-e (org-export) :: Invokes the export dispatcher interface. 

Org exports the =entire buffer= by default. If the Org buffer has an active
region, then Org exports =just that region=.

Within the dispatcher interface, the following key combinations can further
alter what is exported, and how.

+ C-a :: Toggle asynchronous export.
+ C-b :: Toggle body-only export. Useful for excluding headers and footers in
  the export.
+ C-s :: Toggle sub-tree export.
+ C-v :: Toggle visible-only export.

*** Export Settings

Export options can be set: globally with variables; for an individual file by
making variables buffer-local with in-buffer settings.by setting individual
keywords or specifying them =in compact form= with the =‘OPTIONS’= keyword; or for a
tree by setting properties (see Properties and Columns). Options set at a
=specific level= override options set at a more general level.

可以 #+ 然后按 M-TAB 自动提示，如 OPTIONS 后，再an M-TAB 来提示这个参数支持的参
数。

+ ‘SELECT_TAGS’ :: The default value is ‘("export")’. When a tree is tagged with
  ‘export’ (org-export-select-tags), Org selects that tree and its sub-trees for
  export. Org excludes trees with ‘noexport’ tags, see below.
+ ‘EXCLUDE_TAGS’ :: The default value is ‘("noexport")’. When a tree is tagged
  with ‘noexport’ (org-export-exclude-tags), Org excludes that tree and its
  sub-trees from export.
+ broken-links :: Toggles if Org should continue exporting upon finding a broken
  internal link. When set to mark, Org clearly marks the problem link in the
  output (org-export-with-broken-links).
+ toc :: Toggle inclusion of the table of contents, or set the level limit
  (org-export-with-toc).
  
The =‘OPTIONS’= keyword is a compact form. To configure multiple options, use
=several ‘OPTIONS’ lines=.

对于特定 exporter 模式，有对应的 BEGIN_EXPORT Block 和 ATTR:
#+begin_example
,#+BEGIN_EXPORT ascii
Org exports text in this block only when using ASCII back-end.
,#+END_EXPORT

#+ATTR_ASCII: :width 10
#+end_example

*** Table of Contents

The table of contents includes all headlines in the document. Its depth is
therefore the same as the headline levels in the file.
#+begin_example
#+OPTIONS: toc:2          (only include two levels in TOC)
#+OPTIONS: toc:nil        (no default TOC at all)
#+end_example

可以为 headline 指定是否输出到 toc 中：
#+begin_example
,* Subtree not numbered, not in table of contents either
  :PROPERTIES:
  :UNNUMBERED: notoc
  :END:
#+end_example

Org normally inserts the table of contents directly before the first headline of
the file. To move the table of contents to =a different location=, first turn off
the default with org-export-with-toc variable or with ‘#+OPTIONS: toc:nil’. Then
insert ‘#+TOC: headlines N’ at the desired location(s).

#+begin_example
,#+OPTIONS: toc:nil
...
,#+TOC: headlines 2
#+end_example

*** Include Files

During export, you can include the content of another file. For example, to
include your ‘.emacs’ file, you could use:
#+begin_example
,#+INCLUDE: "~/.emacs" src emacs-lisp
#+end_example

Inclusions may specify a file-link to extract an object matched by
org-link-search126 (see Search Options). The ranges for ‘:lines’ keyword are
relative to the requested element. Therefore,

#+begin_example
,#+INCLUDE: "./paper.org::*conclusion" :lines 1-20
#+end_example

+ C-c ' (org-edit~special) :: Visit the included file at point.

*** Comment Lines

Lines starting with zero or more whitespace characters followed by one =‘#’= and =a
whitespace= are treated as comments and, as such, are =not exported=.

Likewise, regions surrounded by =‘#+BEGIN_COMMENT’ … ‘#+END_COMMENT’= are not
exported.

Finally, =a ‘COMMENT’ keyword at the beginning of an entry=, but after any other
keyword or priority cookie, comments out the entire subtree. In this case, the
subtree is not exported and no code block within it is executed either128. The
command below helps changing the comment status of a headline.

+ C-c ; (org-toggle-comment) :: Toggle the ‘COMMENT’ keyword at the beginning of
  an entry.

*** HTML Export

HTML Exporter backend 识别的标记：
1. inline syntax: ‘@@html:...@@’： @@html:<b>@@bold text@@html:</b>@@
2. #+HTML: Literal HTML code for export
3. htlmll export block:
#+BEGIN_EXPORT html
  All lines between these markers are exported literally
  <h1> h1 标题</h1>
#+END_EXPORT

如果将变量 org-html-doctype-alist 设置为 html5, 且  org-html-html5-fancy 设置为
t, 则 org 将任意 block 翻译为 html5 的 element:
#+begin_example
#+BEGIN_aside
  Lorem ipsum
#+END_aside
#+end_example

输出为：
#+begin_example
<aside>
  <p>Lorem ipsum</p>
</aside>
#+end_example

而：
#+begin_example
#+ATTR_HTML: :controls controls :width 350
#+BEGIN_video
#+HTML: <source src="movie.mp4" type="video/mp4">
#+HTML: <source src="movie.ogg" type="video/ogg">
Your browser does not support the video tag.
#+END_video
#+end_example

输出为：
#+begin_example
<video controls="controls" width="350">
  <source src="movie.mp4" type="video/mp4">
    <source src="movie.ogg" type="video/ogg">
      <p>Your browser does not support the video tag.</p>
</video>
#+end_example

Headlines are exported to ‘<h1>’, ‘<h2>’, etc. Each headline gets the ‘id’
attribute from =‘CUSTOM_ID’= property, or a unique generated value, see Internal
Links.

Org files can also have special directives to the HTML export back-end. For
example, by using =‘#+ATTR_HTML’= lines to specify new format attributes to <a> or
<img> tags. This example shows changing the link’s title and style:

#+ATTR_HTML: :style text-align:center;
#+begin_p
#+ATTR_HTML: :alt my picture :style color:red;width:500px;height:600px;
file:~/Pictures/IMG_5648.jpeg
#+end_p

#+ATTR_HTML: :alt my picture :style color:red;width:100px;height:100px;
[[file:~/Pictures/IMG_5648.jpeg][img]]


#+CAPTION: This is a table with lines around and between cells
#+ATTR_HTML: :border 2 :rules all :frame border
| name  | age   | number |
|-------+-------+--------|
| asdfa | asdfa |        |
| asdf  |       |        |
|-------+-------+--------|

注意：#+ATTR_HTML 必须位于要设置的 html element 之前。

When the link in the Org file has no description, the HTML export back-end by
default in-lines that image. For example: =‘[[file:myimg.jpg]]’= is in-lined,
while =‘[[file:myimg.jpg][the image]]’= links to the text, ‘the image’. For more
details, see the variable org-html-inline-images.

*** Publishing

Org includes a publishing management system that allows you to configure
automatic HTML conversion of projects composed of interlinked Org files.

*** Working with Source Code

Users can control how live they want each source code block by tweaking the
=header arguments= (see Using Header Arguments) for compiling, execution,
extraction, and exporting.

For editing and formatting a source code block, Org uses an appropriate Emacs
=major mode= that includes features specifically designed for source code in that
language.

Org can extract one or more source code blocks and write them to one or more
source files—a process known as =tangling= in literate programming terminology.

For exporting and publishing, Org’s back-ends can format a source code block
appropriately, often with =native syntax highlighting=.

+ C-c C-v t（org-babel-tangle)： 将 source code 输出到文件中。

** babel

如果执行 go 代码时出错，提示
#+begin_example
Debugger entered--Lisp error: (wrong-number-of-arguments (1 . 1) 2) 
generate-new-buffer(" *temp file*" t)
#+end_example
则可以删除 ob-go package, 然后重新下载和字节编译。
* font

查看光标文字的字体：M-x describe-char

指定 font 方式：
1. a =Fontconfig= pattern. Fontconfig patterns have the following form:
   fontname[-fontsize][:name1=values1][:name2=values2]... 示例：Sarasa Mono Slab
   TC,等距更紗黑體 Slab TC,等距更紗黑體 Slab TC Light,Sarasa Mono Slab TC
   Light:style=Light Italic,Italic
2. use a GTK font pattern. These have the syntax fontname [properties]
   [fontsize]示例： Monospace Bold Italic 12
3. use an XLFD (X Logical Font
   Description). -misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1示
   例：-*-Iosevka SS14-normal-normal-expanded-*-14-*-*-*-m-0-iso10646-1

On X, Emacs recognizes two types of fonts: =client-side fonts=, which are provided
by the =Xft and Fontconfig libraries=, and =server-side= fonts, which are provided
by the X server itself.

For Xft and Fontconfig fonts, you can use the =fc-list= command to list the
     available fixed-width fonts, like this: fc-list :spacing=mono fc-list
     :spacing=charcell

为图形 frame 指定缺省字体：
#+begin_src lisp
  (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-10"))
#+end_src

不建议使用文泉驿字体了，很久没有更新了， 建议使用 Adobe 和 Google 合作的开源字体：
https://fonts.google.com/?subset=chinese-simplified

Serif typeface for setting text. Designed to complement Source Sans Pro:
https://github.com/adobe-fonts/source-serif-pro

Sans serif font family for user interface environments
https://github.com/adobe-fonts/source-sans-pro

Source Han Serif | 思源宋体 | 思源宋體 | 源ノ明朝 | 본명조:
https://github.com/adobe-fonts/source-han-serif

Source Han Sans | 思源黑体 | 思源黑體 | 思源黑體 香港 | 源ノ角ゴシック | 본고딕:
https://github.com/adobe-fonts/source-han-sans

Source Han Mono | 思源等宽 | 思源等寬 | 思源等寬 香港 | 源ノ等幅 | 본모노:
https://github.com/adobe-fonts/source-han-mono

思源字体是 Adobe 和 Google 合作的字体，用在 Google Android 设备中，称为 Noto 字体。
+ 拉丁字体
  + Noto Sans - 无衬线
  + Noto Serif - 衬线
  + Sarasa Term SC - 等宽（直接使用 Iosevka Term 会导致 emacs 中的蜜汁+）
bug 中文字体
  + Noto Sans CJK SC (又称 思源黑体）
  + Noto Serif CJK SC （又称 思源宋体）

安装字体
+ noto-fonts Noto Sans, Noto Serif
+ noto-fonts-cjk Noto Sans CJK SC, Noto Serif CJK SC
+ noto-fonts-emoji Emoji

在用 org-mode 显示表格时，如果字体不等宽，会导致表格不能对齐。设置字体和等宽：
https://github.com/tumashu/cnfonts

但是设置了等宽后，又存在中文和英文字体高度不一致的问题。emacs 字体等宽和等高不可
兼得：http://baohaojun.github.io/blog/2012/12/19/perfect-emacs-chinese-font.html

* folding

emacs 的 hs-minor-mode 用来 block 的展开和关闭，对应的快捷键前缀是 C-c @ C-x

https://www.gnu.org/software/emacs/manual/html_node/emacs/Hideshow.html

Hideshow mode provides the following commands:

C-c @ C-h
C-c @ C-d
Hide the current block (hs-hide-block).
C-c @ C-s
Show the current block (hs-show-block).
C-c @ C-c
C-c @ C-e
Either hide or show the current block (hs-toggle-hiding).
S-mouse-2
Toggle hiding for the block you click on (hs-mouse-toggle-hiding).
C-c @ C-M-h
C-c @ C-t
Hide all top-level blocks (hs-hide-all).
C-c @ C-M-s
C-c @ C-a
Show all blocks in the buffer (hs-show-all).
C-u n C-c @ C-l
Hide all blocks n levels below this block (hs-hide-level).
These variables can be used to customize Hideshow mode:

+ hs-hide-comments-when-hiding-all :: If non-nil, C-c @ C-M-h (hs-hide-all)
  hides comments too.
+ hs-isearch-open :: This variable specifies the conditions under which
  incremental search should unhide a hidden block when matching text occurs
  within the block. Its value should be either code (unhide only code blocks),
  comment (unhide only comments), t (unhide both code blocks and comments), or
  nil (unhide neither code blocks nor comments). The default value is code.

* dired

+ C-x C-d dir-or-pattern RET：list directory；
+ C-u C-x C-d dir-or-pattern RET：list directory verbosly；可以指定 wild char pattern。
+ M-x make-directory
+ M-x delete-directory
+ M-x copy-directory：递归拷贝
+ M-x delete-file
+ M-x move-file-to-trash
+ M-x copy-file
+ M-x rename-file
+ M-x make-symbolic-link
+ M-x set-file-modes
+ M-x write-region
+ M-x append-to-file
+ M-x make-symbolic-link

C-u C-x d：指定 dired 的显示方式，即传递给 ls 的参数，如 -lR。

查看文件：
|---------+--------------------+------------------------------------------------------------|
| f、e、v |                    | 查看文件                                                   |
| o       |                    | 其它窗口查看文件                                           |
| C-o     |                    | 其它窗口查看文件，光标位于 dired 中                        |
| j       | dired-goto-file    | 调整到指定文件或目录                                       |
| a       |                    | 下一级目录（不建议使用，它会替换当前 buffer 中的所有目录） |
| '^'     | dired-up-directory | 移动到上一级目录                                           |

% 开头的都是和正则表达式相关的命令（类比 C-M-% 的 Query Replace Regexp）：
|---------------------+---+--------------------------------|
| %m                  |   | 根据文件名称正则标记           |
| m                   |   | 标记当前行文件                 |
| %g                  |   | 根据文件内容标记               |
| %C                  |   | 根据正则标记要拷贝的文件       |
| %R、%r              |   | 根据正则要移动的文件           |
| %d                  |   | 根据正则匹配要删除的文件文件名 |
| %&                  |   | 删除标记垃圾文件               |
| %u                  |   | 文件名大写                     |
| %l                  |   | 文件名小写                     |
| % R from RET to RET |   | 支持正则分组和 \n 形式的引用   |
| % C from RET to RET |   |                                |
| % H from RET to RET |   |                                |
| % S from RET to RET |   |                                |

=*= 开头的都是按照类型标记文件：
| **                   | 标记可执行文件                   |
| *@                   | 标记链接文件                     |
| */                   | 标记目录文件                     |
| *s                   | 标记当前子目录中的所有文件       |
| * C-n、* C-p         | 移动到下一个标记或上一个标记文件 |
| *% regexp、%m regexp | 按正则标记文件名                 |

标记时可以将 directory 隐藏，这样他们就不会被标记。

目录和子目录：
|----------+---------------------------+----------------------------------|
| i        | dired-maybe-insert-subdir | 在当前 buffer 插入子目录         |
| C-u s    |                           | 修改当前 Buffer 的展示方式       |
| C-u i    |                           | 插入子目录时指定子目录的展示方式 |
| M-{、M-} |                           | 在标记的文件间移动               |
| < 、>    |                           | 在目录间移动                     |
| '$'      |                           | 显示或隐藏当前子目录             |
| M-$      |                           | 隐藏所有目录                     |
| C-M-n    |                           | 下一个子目录                     |
| C-M-p    |                           | 上一个子目录                     |
| C-M-u    |                           | 上一级子目录                     |
| C-M-d    |                           | 当前目录的第一个子目录           |

搜索和替换：
|---+---+--------------------------------------------|
| A |   | 在标记的文件或目录（递归）搜索文件内容     |
| Q |   | 在标记的文件或目录（递归）查询替换文件内容 |

递归查询的内容在 *xref* Buffer 中显示，可以执行如下命令：
+ n、p：移动
+ g: 刷新
+ q: 关闭
+ C-o: 其它窗口显示
+ r pattern RET replacement RET: Perform interactive query-replace on references that match pattern
  (xref-query-replace-in-results), replacing the match with replacement.

在文件上执行 shell 命令：
|------+---+-------------------------------|
| X、! |   | 在标记的文件上执行 shell 命令 |
| &    |   | 异步执行命令                  |

如果标记了多个文件，则：
1. 如果命令行中包括 *，而且前后都有空格，则将空格分隔的标记文件列表替换命令行中的 *；
  + 如果想使用没有特殊含义的 *，可以在 * 后面添加""，这样就打破了上面的前后都有空格的约束；
2. 如果命令行中包括 ? 且前后都有空格，则一次传给命令一个文件，用文件名替换命令行中的 ?；
3. 否则一次传给命令一个文件，且将文件名添加到命令行尾部；

其它：
|-------------+---+----------------------------------------------------------|
| ~           |   | 删除标记备份文件                                         |
| #           |   | 删除标记备份文件                                         |
| s           |   | 按照文件名或修改时间排序                                 |
| d           |   | 删除文件                                                 |
| l、g        |   | 刷新 buffer                                              |
| t           |   | 当前 buffer 标记和未标记切换                             |
| +           |   | 创建目录                                                 |
| w           |   | 拷贝文件名称, 0w 表示拷贝文件完整路径，C-uw 表示相对路径 |
| =           |   | 比较光标文字文件和输入的另一个文件                       |
| u           |   | 不标记文件                                               |
| U           |   | 不标记所有文件                                           |
| C new       |   | 拷贝文件                                                 |
| D           |   | 立即删除文件                                             |
| R new       |   | 重命名文件                                               |
| H new       |   | 建立硬链接                                               |
| S new       |   | 建立软链接                                               |
| M modespec  |   |                                                          |
| G newgroup  |   |                                                          |
| O newowner  |   |                                                          |
| T timestamp |   |                                                          |
| C-u k       |   | 从 Buffer 中删除当前目录中当前行及后续行文件             |
|-------------+---+----------------------------------------------------------|

递归搜索目录文件，然后通过 dired 形式展示：
+ M-x find-grep-dired：按照文件内容查找，然后显示在 dired buffer 中；
+ M-x find-name-dired: 按照文件名查找，然后显示在 dired buffer 中；
+ M-x find-dired: 最通用的形式，可以指定 find 的参数，来实现按照文件名或内容来查找；

Wdired(Writeable dired):在 Dired Buffer 中按 C-x C-q，然后可以对文件名进行编辑，移动（但是类型、用户、大小和时间等是只读的）。结束后 C-c C-c 保存，C-c
 C-k 丢弃修改。

+ M-x grep
+ M-x grep-find
+ M-! find
+ M-x ffap

* selectrum

+ C-M-<backspace>") #'backward-kill-sexp) ：快速删除上一级目录
+ C-j") #'selectrum-submit-exact-input) ：使用输入内容而非候选的内容，可以向上移
  动候选的内容到输入行达到同样的效果； =C-m= ：选中并回车当前候选处的内容。
+ TAB") #'selectrum-insert-current-candidate) ：在光标处插入选中的候选者，如果是
  目录则选中目录。
+ M-i") 'selectrum-quick-insert) ; 快速插入（快速选中，但是不回车）；
+ M-m") 'selectrum-quick-select) ; 快速选择，并确定（自动回车）；
  + M-i 和 M-m 快速操作，只会为当前可见的候选者显示快捷键，如果候选内容比较多，
    则可以先输入一部分过滤内容，然后再使用这两个快捷键。
+ M-q") 'selectrum-cycle-display-style) ：循环显示候选风格；

+ To ~navigate~ to a candidate: use the standard motion commands (<up>, <down>,
  C-v, M-v, M-<, M->). If you prefer, you can use C-p and C-n instead of the
  arrow keys.
+ To ~accept~ the currently selected candidate: type ~RET/C-m~. (With a prefix
  argument, accept instead the candidate at that point in the list, counting
  from one. See selectrum-show-indices. The value zero means to accept exactly
  what you've typed, as in the next bullet point.) You can also click the left
  mouse button on a candidate to choose it or use ~M-m~ to select one using
  selectrum-quick-keys.
+ To submit what you've typed, even if it's not a candidate: you can use ~<up> or
  C-p~ to ~select the user input~ just like a regular candidate, and type RET as
  usual. (Alternatively, you can type ~C-j~ to submit your exact input without
  selecting it first.)
+ To abort: as per usual, type C-g.
+ To navigate into the currently selected directory while finding a file: type
  ~TAB/C-i~. (What this actually does is insert the currently selected candidate
  into the minibuffer, which for find-file has the effect of navigating into a
  directory.) With a positive prefix argument, insert the candidate at that
  display position (see selectrum-show-indices). You can also right click on a
  candidate to insert it into the minibuffer or use ~M-i~ for inserting one using
  selectrum-quick-keys.
+ To copy the current candidate: type ~M-w~ or what is bound to
  kill-ring-save. When there's an active region in your input, this still copies
  the active region. The behavior of M-w is not modified when Transient Mark
  mode is disabled.
+ To select multiple candidates: separate them with =crm-separator (, by
  default)=. To make this workflow more convenient, you can use TAB to complete
  the currently selected candidate before typing crm-separator (for common
  values of crm-separator it will be automatically inserted for you). This
  feature ~only works~ in commands that use completing-read-multiple, such as
  describe-face. (If multiple selection is enabled, it is shown in the
  minibuffer prompt.)
+ To change the display style of candidates: use ~M-q~ which will cycle from the
  currently used style through the styles in
  selectrum-display-style-cycle-list. With the default configuration this
  command will toggle between the vertical and an icomplete like horizontal
  display.
+ All your standard horizontal motion, selection, insertion, and deletion
  commands work as usual.
+ To delete your current input, just use ~C-a C-k or C-S-backspace~ (bound to
  kill-whole-line).
  + C-a C-k 删除当前输入行；（光标不是先移动到行首）
  + C-S-backspace：删除当前行
  + C-M-backspace：删除上一级目录
+ To edit by word units use M-DEL like usual. ~To go up a directory you can use
  ~C-M-DEL~ (bound to backward-kill-sexp). Be aware that on some Linux
  distributions, this binding is used to kill the X server, which can force-quit
  all programs you opened. Therefore, accidentally killing the X server can
  cause data corruption and loss of unsaved work. In such cases, you can instead
  use ESC C-DEL, which Emacs helpfully binds by default.
+ To navigate to your home directory, you can just use C-a C-k ~/. Alternatively,
  like in default completion, you can ~type \~/ after a /~ to ignore the preceding
  input and move to the home directory.
  + 如果要切换到根路目录 /，则可以在当前目录后面连续输入两个 ////
+ Minibuffer history navigation works as usual with =M-p= and =M-n=. M-r will invoke
  an improved version of history search with completion.

* consult

consult 给 selectrum 提供了实时预览功能。

consult-buffer (-other-window, -other-frame): Enhanced version of
switch-to-buffer with support for =virtual buffers=. Supports =live preview= of
buffers and narrowing to the virtual buffer types. You can type =f SPC= in order
to narrow to recent files. Ephemeral buffers can be shown by pressing SPC - it
works the same way as switch-buffer. Supported narrowing keys:
  + b Buffers
  + f Files
  + m Bookmarks
  + p Project (only available if consult-project-root-function is configured as
    shown in the example configuration).

By default =only buffers are preview= in order to ensure that consult-buffer is
fast, but it is possible to configure =file and bookmark= preview.
+ consult-bookmark: Select or create bookmark. You might use the powerful
  consult-buffer as an alternative, which can include a bookmark virtual buffer
  source. But note that consult-bookmark supports preview of bookmarks and
  narrowing.
+ consult-recent-file: Select from recent files with preview. You might prefer
  the powerful consult-buffer instead, which can =include= recent files as a
  virtual buffer source.

+ consult-grep 的参数是由 # 分隔的两部分字符串组成：
  + #async-regexp -- grep-opts#filter-string
  + async-regexp 为正则表达式；
  + -- 后面的 grep-opts 是传给 grep 的参数；
  + 第二个 filter-string 是对 async-regexp 的结果进行进一步过滤；

consult 提供了一些 M-s 为前缀的命令，用于搜索：
+ M-s m：consult-multi-occur，自动补全多个 buffer，然后执行 multi-occur 命令；
+ M-s g、G、r：在 project 级别搜索文件内容；
+ M-s f：在 project 级别搜索文件名；
+ M-s k (consult-keep-lines): 在 buffer 中只显示匹配正则的行；
+ M-s u (consult-focus-lines): 和 consult-keep-lines 类似，但是使用 overlays 的
  显示方式；
+ M-s e (consult-isearch): consult 列出 search history，可以选择一个搜索。在
  isearch 过程中可以使用 M-e、M-s e 切换到 consult-isearch 来选择搜索历史；

在使用 minibuffer 时，M-r、M-s 用于对 minibuffer history 进行搜索，consult 提供
了实时预览功能。

consult 提供了一些 M-g 为前缀的命令，用于快速跳转：
+ M-g k：调转到全局 mark ring
+ M-g m：跳转到当前 buffer mark ring
+ M-g i：显示 imenu
+ M-g o：显示 outline
+ M-g f：显示 flycheck 错误
+ M-g e：显示 Compilation 错误

consult-lsp 提供了两个非常好用的函数：
+ consult-lsp-symbols :: 在 lsp workspace 中搜索 Symbol
+ consult-lsp-diagnostics :: 在 lsp workspace 中搜索诊断信息

* embark

embark 用于给 consult 候选者提供一个快捷操作命令，对应的命令是 embark-act（快捷
键 C-;)。可以在任何位置执行 embark-act 命令，然后使用 C-h 查看可用的上下文命令：
+ In the minibuffer, the target is the current best completion candidate.
+ In the *Completions* buffer the target is the completion at point.
+ In a regular buffer, the target is the region if active, or else the file,
  symbol or URL at point.

C-h 列出的 embark action 支持自动补全。但是如果安装了 =which-key= ，执行 C-; 命令
后会自动提示可用的 action 快捷键。

Embark’s default configuration has actions for the following target types:
~files, buffers, symbols, packages, URLs, bookmarks~, and as a somewhat special
case, actions for when ~the region~ is active. You can read about the default
actions and their keybindings on the GitHub project wiki.

Embark Collect：类似于 helm-occur、ivy-occur，用来对一批候选对象、搜索结果列表等
进行操作。
+ embark-collect-snapshot（S）：在 Embark Collect Buffer 中显示候选情况，不更新
  Buffer 内容；
+ embark-collect-live（L)：根据候选情况，实时更新 Embark Collect Live Buffer 中
  的内容；
+ embark-export（E）：根据当前候选者的不同（可以使用 b/f/m SPC 来缩小类型范围），
  将结果显示在不同的 Buffer 中：
  + Dired： 如果候选者是文件，则将结果显示到 Dired Buffer 中；
  + Embark Export Ibuffer: 如果候选者是 Buffer；
  + Embark Export Grep: 对consult-grep、consult-git-grep、consult-ripgrep 等搜索
    结果进行 export 时，进入 Embark Export Grep 模式；
    +  该模式下，可以使用 =C-c C-p= 切换到 =wgrep= 模式，然后对结果进行批量编辑；
  + Embark Collect：如果没有指定候选者类型（如 Buffer、File、Project 等）；
  + Embark Collect Live：如果没有指定候选者类型（如 Buffer、File、Project 等）；

+ embark-insert: 将当前候选内容(如文件名、Buffer 名称等)插入到光标处。
+ embark-save: 将当前候选内容保存到剪切环，后续可以用于粘贴；

embark-become（B）：将当前执行的命令替换为另一个（输入内容不变）。如当前正在执行
switch-to-buffer 命令，但是想切换到 find-file，则可以使用该命令。在执行 B action
后，可以直接输入其它命令，或者，使用 embark-become 提供的快捷键；

*** Default Actions

https://github.com/oantolin/embark/wiki/Default-Actions

Remember that you can ~use any Emacs command~ as an Embark action, but for
convenience some commands are given easy, usually single-letter, keybindings in
the Embark keymaps. This page lists the keybindings for actions that come with
embark by default. In a few cases the action is not simply a built-in Emacs
command, so we list a one-sentence description instead.

*** General
+ i: insert target in previously selected buffer
+ w: save target in kill-ring
+ C-g: cancel action
+ C-h: pop up help buffer with available keybindings for actions
+ C-u, 0 ... 9: set prefix arguments for action

*** File
+ f: find-file
+ o: find-file-other-window
+ d: delete-file
+ D: delete-directory
+ r: rename-file
+ c: copy-file
+ !: shell-command
+ &: async-shell-command
+ =: ediff-files
+ e: Open eshell in directory of target
+ +: make-directory
+ I: insert relative path; 在当前光标位置插入相对路径
+ W: save relative path ; 将相对路径复制到剪切环
+ x: open file externally in default application registered with OS

*** Buffer
+ k: kill-buffer
+ b: switch-to-buffer
+ o: switch-to-buffer-other-window
+ z: bury buffer
+ q: kill buffer and window
+ r: rename buffer
+ =: ediff-buffers
+ |: shell command on buffer

*** Symbol (commands, functions & variables)

+ h: describe symbol
+ c: lookup command in Emacs info manual
+ s: lookup symbol in Elisp info manual
+ d: goto definition
+ e: eval-expression (for a variable this immediately shows the value, but for a function it wraps
  it in parenthesis and leaves point ready to insert arguments)

*** Packages

+ h: describe-package
+ i: package-install
+ d: package-delete
+ r: package-reinstall
+ u: use browse-url to open the package homepage

*** Unicode character names

+ I: insert named unicode character in previously selected buffer (note that i would insert the
  unicode character's name, this inserts the character)
+ W: save named unicode character in kill-ring (note that w would save the character's name in the
  kill-ring)

*** Active region

These actions are offered if there is an active region in the current buffer.

+ u: upcase-region
+ l: downcase-region
+ c: capitalize-region
+ |: shell-command-on-region
+ e: eval-region
+ f: fill-region-as-paragraph
+ r: rot13-region
+ =: count-words-region
+ s: whitespace-cleanup-region
+ o: org-table-convert-region
+ ;: comment-or-uncomment-region
+ w: write-region
+ m: apply-macro-to-region-lines
+ n: narrow-to-region
+ RET: examine the contents of the active region and offer the appropriate
  actions for its type (currently this detects files, symbols and buffer names).

* workflow

输入法：
1. 使用 sis 的 im-select 切换工具，只有这样才能正确激活中文输入法；
2. sis 需要明确切换到搜狗时输入的是中文，所以需要关闭搜狗输入法英文切换功能，只
   用于输入中文；
4. 如果要手动切换输入法，使用系统快捷键(C-M-\)，而非 sis 绑定的 Emacs 快捷键，这
   样即使 Emacs 处于全屏模式，也可以看到切换到的输入法类型；

Clone 项目
+ magit-clone 指定 URL 和保存路径。

注册项目
+ projectile 和 treemacs

切换项目：
+ projectile

项目中按照文件名搜索：
+ projectile：C-c p f
+ consult：M-s f
注意：建议系统安装 fd，这样速度最快；

项目中按照文件内容搜索：
+ projectile：C-c p s r
+ consult：M-s g 或 G 或 r
注意：推荐使用 rg 来搜索，这样速度最快；

checkout 分支：
+ magit：C-x G -> b -> l(local branch)

查看文件结构
+ consult：M-g i

代码快速浏览/导航
+ C-M-a C-M-e: 按照函数跳转
+ C-M-d C-M-u: 深入或跳出到当前层次
+ C-M-n C-M-p: 按照列表或括号前进，非常实用
+ C-M-f C-M-b: 按照语法前进，粒度比 C-M-n/p 小
+ M-g l：快速跳转到指定行
+ C-': 输入两个字符，快速跳转

快速选中符号
+ C-=：多按几次选择；
+ C-M-SPC：选择光标处 sexp

<<<<<<< HEAD
=======
* term&shell

+ M-! cmd RET :: Run the shell command cmd and display the output (shell-command).
+ M-| cmd RET :: Run the shell command cmd with region contents as input;
  optionally replace the region with the output (shell-command-on-region).
+ M-& cmd RET :: Run the shell command cmd asynchronously, and display the
  output (async-shell-command).
+ M-x shell :: Run a subshell with input and output through an Emacs buffer. You
  can then give commands interactively.
+ M-x term :: Run a subshell with input and output through an Emacs buffer. You
  can then give commands interactively. Full terminal emulation is available.

A numeric argument to shell-command, e.g., =M-1 M-!=, causes it to insert terminal
output =into the current buffer= instead of a separate buffer.

To make multiple subshells, invoke =M-x shell= with a prefix argument (e.g., =C-u
M-x shell=). Then the command will read =a buffer name=, and create (or reuse) a
subshell in that buffer. You can also rename the *shell* buffer using =M-x
rename-uniquely=, then create a new *shell* buffer using plain M-x shell. Subshells
in different buffers run independently and in parallel.

Shell mode：不支持终端转义字符， =不建议使用= ；
+ 如果在 M-x shell 环境，则 emacs 设置环境变量 =INSIDE_EMACS= in the subshell to
    ‘version,comint’,这样可以针对性的初始化 shell。
+ C-c C-u、C-c C-w、C-c C-c、C-c C-\、C-c C-z
+ C-c C-o：删除上一个命令的输出
+ C-c C-s：将上一个命令的输出保存到指定 buffer
+ C-c C-r 或 C-M-l：将上一个命令的输出置到 window 的顶部；
+ M-p、M-n、M-r、C-c C-n、C-c C-p：命令历史记录
+ C-c C-l：在另一个 buffer 中展示当前 shell buffer 的历史记录； 然后可以搜索，
    回车确定；

Term mode： =建议使用= ，可以使用 top、vim 等：
+ C-c C-j：term-line-mode，切换到 Emacs 编辑模式，直到按回车键（将当前行发送给
    终端）。在粘贴拷贝的内容前，不能按回车。
+ C-c C-k：term-char-mode，切换到终端模式，输入的任何字符都会直接发送给终端
    （ 除了 C-c 字符外）。
+ C-c C-c: 向 shell 进程发送 C-c 命令；

C-c C-q: C-c C-q Toggle the page-at-a-time feature (term-pager-toggle). 在 line
  和 char mode 都可以启用，当 term 输出超过一页时会暂停，按 SPACE 继续。

* image

如果显示的照片比当前 window 大，则可以使用 C-n、C-p 等移动命令来查看文件的部分内
容，也可以使用照片缩放快捷键：
+ s b (image-transform-fit-both)；
+ s s (image-transform-set-scale)；
+ s 0 (mage-transform-reset)；
+ n (image-next-file)：访问目录中的下一个文件；
+ p (image-previous-file)：访问目录中的上一个文件；
+ C-<鼠标滚轮>：放大或缩小照片；

另外，通过 dired 也可以快速查看目录中各照片的 thumbnail，并对照片添加 tag、
comment 等：
+ 在 dired mode 中先 mark 照片，然后使用 C-t d (image-dired-display-thumbs) 来查
  看这些照片的 thumbnail；
+ 或者，直接使用 M-x image-dired 命令，来显示指定目录中所有照片的 thumbnail；

这会打开一个 =*image-dired*= buffer，在这个 buffer 中，可以：
1. RET (image-dired-display- thumbnail-original-image)
2. SPC (image-dired-display-next-thumbnail-original)
3. DEL (image-dired-display- previous-thumbnail-original)
4. d (image-dired-flag-thumb- original-file)
5. C-d (image-dired-delete-char)

org mode 情况下，可以使用 C-c C-x C-v 来显示图片。

* web 开发

Emacs 侧配置：
1. typescript-mode: 编辑 ts/tsx 文件的 major-mode.
2. js2-mode: 继续使用 Emacs 27 的 js-mode（major-mode) 来编辑 js/jsx 文件，但是
   开启js2-minor-mode 来增强 jsx 的支持。
3. tide: 为 typescript-mode/js-mode/js2-mode 提供语法代码补全、符号跳转等特性；
4. web-mode: 为 html/css/tmpl 等模板类型文件提供缩进、高亮等特性的 major-mode.
5. dap-mode: 为 js/jsx/ts/tsx/go/python/java 等语言项目提供调试功能的
   major-mode.

建议使用 nvm 来管理 node/npm/yarn 版本：
#+begin_src bash
# 安装最新版本
zhangjun@zj-pc16:~$ nvm install node
# 安装指定版本
zhangjun@zj-pc16:~$ nvm install v14.17.0 
# 当前 shell session 使用指定版本 node
zhangjun@zj-pc16:~$ nvm use v14.17.0
# 设置全局缺省 node 版本
zhangjun@zj-pc16:~$ nvm alias default v14.17.0
#+end_src

通过在项目的根目录添加 .nvmrc 文件，其中指定 node 版本，可以实现各项目使用自己的
版本：

#+begin_src bash
  mkdir v1
  echo 'v14.17.0' >v1/.nvmrc
  cd v1
  
  # 这时, 在这个项目根目录和子目录执行的 nvm 命令, 如 nvm use, nvm install, nvm
  # exec, nvm run, and nvm which 都会自动使用这个版本。如果要在当前 shell session
  # 中使用这个版本，可以执行 nvm use 命令。
#+end_src

上面需要在项目目录执行 nvm 命令才能切换到对应版本，通过使用 avn 会在 cd 到项目目
录时自动切换版本：
#+begin_src bash
rm -R ~/.avn
nvm install 10.13.0
nvm exec 10.13.0 npm install -g avn avn-nvm avn-n
nvm exec 10.13.0 avn setup
#+end_src

创建一个 react app:
#+begin_src bash
npx create-react-app my-app
cd my-app
npm start
#+end_src

执行 npm start 后，会自动打开一个 local http server 和浏览器，显示 web app 。

tide 默认会根据项目的 jsconfig.json 和  tsconfig.json 文件来确定 project root 目
录，所以一般需要在项目的根目录中包含其中一个文件，例如 jsconfig.json 文件内容如
下：
#+begin_src json
{
    "compilerOptions": {
        "target": "es2016",
        "noEmit": true,
        "checkJs": true,
        "allowJs": true,
        "allowSyntheticDefaultImports": true,
        "jsx": "react",
        "lib": [ "dom", "es2017" ]
    },
    "exclude": [
        "node_modules",
        ".git"
    ]
}
#+end_src

查看当前 project root: 可以查看 tide-project-root 变量值。

在项目的根目录下创建 .vscode/launch.json 目录和文件，内容如下：
#+begin_src json
{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "chrome",
            "request": "launch",
            "name": "my-app debug 测试",
            "url": "http://localhost:3000",
            "webRoot": "${workspaceFolder}"
        }
    ]
}
#+end_src
+ url 指向 create-react-app 打开的本地浏览器 url 地址。

安装 eslint: 
#+begin_src bash
npm install -g eslint babel-eslint eslint-plugin-react
eslint -v
#+end_src

然后安装 eslint language server: M-x lsp-install-server RET eslint RET. 

创建 .eslintrc.js: M-x lsp-eslint-create-default-configuration, 回答一些问题后自
动创建配置文件并安装 eslint plugin。
 
打开 tide 使用的 ts-ls debug 日志：
#+begin_src lisp
(setq tide-tsserver-process-environment '("TSS_LOG=-level verbose -file /tmp/tss.log"))
#+end_src

执行 M-x dap-chrome-setup 命令来安装 VSCode Chrome Debug Extension ，确认变量
dap-chrome-debug-program 指向正确的 dap 文件。

执行 dap-debug, 从列表中选择上面的 "my-app debug 测试" 配置项目, 开始调试。关于
dap-debug 的详情，可以参考：
https://emacs-lsp.github.io/lsp-mode/tutorials/reactjs-tutorial/

** 'React' refers to a UMD global, but the current file is a module. Consider adding an import instead
这时由于 js 文件中使用了 jsx 语法，例如 let x = <SomeComponent />; 但是没有
import React 导致的错误，解决办法是在文件开头添加 import * as React from
'react'; 参考：https://github.com/Microsoft/TypeScript/issues/14118

** 'React' must be in scope when using JSX react/react-in-jsx-scope?
解决办法：
1. 在文件开头添加 import * as React from 'react';
2. 或者，在 .eslintrc.js/.eslintrcc.json 文件中添加如下内容：
#+begin_src json
  rules: {
    // suppress errors for missing 'import React' in files
   "react/react-in-jsx-scope": "off",
    // allow jsx syntax in js files (for next.js project)
   "react/jsx-filename-extension": [1, { "extensions": [".js", ".jsx"] }], //should add ".ts" if typescript project
  }
#+end_src
+ https://stackoverflow.com/a/61160875

* 不常用
** 多光标编辑

安装 iedit 后可以一次选中整个 buffer 或指定区域里匹配的 symbol、string 或选中的
内容，然后并行编辑（也可以快速的匹配预览）。另外在 isearch 的过程中，也可以对
search 的内容进行 multi-cursor 编辑（按 C-;）：
+ C-; :: 对光标当前的 symbol 或选中的 region 进行 multi-cursor 编辑；再按 C-;
  结束编辑。
+ C-' :: 只显示匹配 multi-cursor 选中的那些行，*可以用作快速的匹配预览*。

#+begin_verse
TAB：iedit-next-occurrence 跳转到下一个选中出现的位置
M-;：toogle selection，选中或不选中当前出现的位置，可以排除编辑
M-H：iedit-restrict-function
M-I：iedit-restrict-current-line
M-n：iedit-expand-down-to-occurrence
M-p：iedit-expand-up-to-occurrence
M-{：iedit-expand-up-a-line
M-}：iedit-expand-down-a-line
#+end_verse

对选中的内容进行快速编辑：

#+begin_verse
M-SPC           iedit-blank-occurrences
M-<             iedit-goto-first-occurrence
M->             iedit-goto-last-occurrence
M-B             iedit-toggle-buffering
M-D             iedit-delete-occurrences
M-L             iedit-downcase-occurrences
M-N             iedit-number-occurrences
M-R             iedit-replace-occurrences
M-U             iedit-upcase-occurrences
#+end_verse

** Macro

#+begin_verse
F3：Start defining a keyboard macro (kmacro-start-macro-or-insert-counter)
F4：If a keyboard macro is being defined, end the definition; otherwise, execute the most recent keyboard macro (kmacro-end-or-call-macro).
C-u F3：Re-execute last keyboard macro, then append keys to its definition.
C-u C-u F3：Append keys to the last keyboard macro without re-executing it.
#+end_verse

** rime

系统搜狗输入法设置：
1. 开启搜狗输入法的中英文切换功能（通常是 Shift 按键）；
2. 偏好设置-〉高级-〉智能输入 -〉自动切换到英文状态 的 App 清单中添加 Emacs。这
   样系统输入法可以一直是搜狗，不会影响到 Emacs 内置的 RIME 输入法；


3. 在 ~/Library/Rime 目录下创建一个名为 clover.custom.yaml 的文件，内容如下：
#+begin_src yaml
patch:
  switches:
  - name: zh_simp_s2t
    reset: 0
    states: [ 简, 繁 ]
  - name: emoji_suggestion
    reset: 0 # 不提示输出 emoji 符号
    states: [ "🈚️️\uFE0E", "🈶️️\uFE0F" ]
  - name: symbol_support # 安装包中默认值为 1, 必须设置为 0, 否则激活输入法后，emacs 卡死；
    reset: 0
    states: [ "无符", "符" ]
  - name: ascii_punct
    reset: 0
    states: [ 。，, ．， ]
  - name: full_shape
    reset: 0
    states: [ 半, 全 ]
  - name: ascii_mode
    reset: 0
    states: [ 中, 英 ]
  speller:
    algebra:  # 开启模糊音，安装包默认没有开启 in ing 模糊音
    - erase/^xx$/                      # 第一行保留

    - derive/^([zcs])h/$1/             # zh, ch, sh => z, c, s
    - derive/^([zcs])([^h])/$1h$2/     # z, c, s => zh, ch, sh

    - derive/^n/l/                     # n => l
    - derive/^l/n/                     # l => n

    - derive/([ei])n$/$1ng/            # en => eng, in => ing
    - derive/([ei])ng$/$1n/            # eng => en, ing => in
#+end_src

4. 在 ~/Library/Rime 目录下创建 default.custom.yaml 文件，内容如下：
#+begin_src yaml
patch:
  schema_list:
    - schema: clover  # 使用 clover 输入法方案
  menu/page_size: 9
  ascii_composer/good_old_caps_lock: true
  ascii_composer/switch_key:
    Caps_Lock: commit_code                    
    Shift_L: inline_ascii
    Shift_R: commit
    Control_L: commit_code
    Control_R: commit_code
  switcher/hotkeys:
    - "Control+grave"
    - "Control+Shift+grave"
    - F4
    - "Control+exclam"  # 增加使用 C-! 快捷键来调出输入法菜单
  key_binder/bindings:
    - { when: composing, accept: ISO_Left_Tab, send: Page_Up }
    - { when: composing, accept: Shift+Tab, send: Page_Up }
    - { when: composing, accept: Tab, send: Page_Down }     
    - { when: paging, accept: minus, send: Page_Up }
    - { when: has_menu, accept: equal, send: Page_Down }
    - { when: paging, accept: bracketleft, send: Page_Up }
    - { when: has_menu, accept: bracketright, send: Page_Down }
    - { when: always, accept: "Control+dollar", toggle: ascii_mode}  # 中英文切换
    - { when: always, accept: "Control+period", toggle: ascii_punct} # 中英文标点切换
    - { when: always, accept: "Control+comma", toggle: full_shape}   # 全角/半角切换
#+end_src

5. 配置 Emacs：
#+begin_src lisp
(use-package rime
  :ensure :demand :after (which-key)
  :custom
  (rime-user-data-dir "~/Library/Rime/")
  (rime-librime-root "~/.emacs.d/librime/dist")
  (rime-emacs-module-header-root "/Applications/Emacs.app/Contents/Resources/include")
  :bind
  ( :map rime-active-mode-map
         ;; 强制切换到英文模式，直到按回车
         ("M-j" . 'rime-inline-ascii)
         :map rime-mode-map
         ;; 中英文切换
         ("C-$" . 'rime-send-keybinding)
         ;; 中英文标点切换
         ("C-." . 'rime-send-keybinding)
         ;; 全半角切换
         ("C-," . 'rime-send-keybinding)
         ;; 输入法菜单
         ("C-!" . 'rime-send-keybinding)
         ;; 强制使用中文模式
         ("M-j" . 'rime-force-enable))
  :config
  ;; Emacs will automatically set default-input-method to rfc1345 if locale is
  ;; UTF-8. https://github.com/purcell/emacs.d/issues/320
  (add-hook 'after-init-hook (lambda () (setq default-input-method "rime")))
  ;; 在开启输入法的情况下，modline 输入法图标是否高亮来区分中文或英文状态中文
  (setq mode-line-mule-info '((:eval (rime-lighter))))
  ;; Emacs 不支持 Shift 键切换输入法：https://github.com/DogLooksGood/emacs-rime/issues/130
  ;; 所以下面的配置不生效：
  ;;(setq rime-inline-ascii-trigger 'shift-l)
  (setq rime-disable-predicates
        '(rime-predicate-ace-window-p
          rime-predicate-evil-mode-p
          rime-predicate-hydra-p
          rime-predicate-which-key-activate-p
          rime-predicate-current-uppercase-letter-p
          rime-predicate-after-alphabet-char-p
          rime-predicate-space-after-cc-p
          rime-predicate-punctuation-after-space-cc-p
          rime-predicate-prog-in-code-p
          rime-predicate-after-ascii-char-p
          ))
   (defun rime-predicate-which-key-activate-p ()
     which-key--automatic-display)
  (setq rime-posframe-properties
        (list :font "Sarasa Gothic SC"
              :internal-border-width 10))
  (setq rime-show-candidate 'posframe))

;; isearch 与 rime 不兼容，通过 phi-search 解决，参考：
;; https://github.com/DogLooksGood/emacs-rime/issues/21
(use-package phi-search
  :ensure :after (rime)
  :config
  (global-set-key (kbd "C-s") 'phi-search)
  (global-set-key (kbd "C-r") 'phi-search-backward))

#+end_src

6. 后续，只要修改了 ~/Library/Rime 目录中的文件，都需要执行 M-x rime-deploy 命令
   生效。

** project

Emacs 26.1 开始内置 project.el 并在 27.1 中得到增强，但是特性和活跃度不如
projectile，建议使用 projectile。

如果项目是 VCS 则 project会自动识别，否则需要将目录注册到 project:
#+begin_src emacs-lisp
;; Declare directories with ".project" as a project
(cl-defmethod project-root ((project (head local)))
  (cdr project))

(defun my/project-try-local (dir)
  "Determine if DIR is a non-Git project.
DIR must include a .project file to be considered a project."
  (let ((root (locate-dominating-file dir ".project")))
    (and root (cons 'local root))))

(add-to-list 'project-find-functions 'my/project-try-local)
#+end_src

或者，在项目根目录中创建一个 .project 文件。

Files that belong to a project are typically stored in a hierarchy of
directories; the top-level directory of the hierarchy is known as the =project
root=.

Whether a given directory is a root of some project is determined by the
project-specific infrastructure, known as =project back-end=. Emacs currently
supports two such back-ends: =VC= (see Section 25.1 [Version Control], page 310),
whereby a VCS repository is considered a project; and =EDE= (see Section 25.5
[EDE], page 342). This is expected to be extended in the future to support
additional types of projects.

project 相关的命令前缀为 C-x p，帮助命令为 C-x p C-h：
#+begin_verse
C-x p !         project-shell-command
C-x p &         project-async-shell-command
C-x p F         project-or-external-find-file
C-x p G         project-or-external-find-regexp
C-x p b         project-switch-to-buffer
C-x p c         project-compile
C-x p d         project-dired
C-x p e         project-eshell
C-x p f         project-find-file
C-x p g         project-find-regexp
C-x p k         project-kill-buffers
C-x p m         magit-project-status
C-x p p         project-switch-project
C-x p r         project-query-replace-regexp
C-x p s         project-shell
C-x p v         project-vc-dir
C-x p x         project-execute-extended-command
#+end_verse

project-find-regexp 的结果在 Xref mode buffer 中显示。

project-search 默认搜索到第一个匹配就停下来，可以使用 M-x fileloop-continue RET
继续。

** compress

Emacs =automatically uncompresses= compressed files when you visit them, and
=automatically recompresses= them if you alter them and save them. Emacs
recognizes compressed files by their file names. File names ending in =‘.gz’=
indicate a file compressed with gzip. Other endings indicate other compression
programs.

A file whose name ends in =‘.tar’= is normally an archive made by the tar
program. Emacs views these files in a special mode called =Tar mode= which
provides a =Dired-like= list of the contents (see Chapter 27 [Dired], page
350). You can move around through the list just as you would in Dired, and visit
the subfiles contained in the archive. However, not all Dired commands are
available in Tar mode.  If Auto Compression mode is enabled (see Section 15.13
[Compressed Files], page 156), then Tar mode is used also for compressed
archives—files with extensions ‘.tgz’, .tar.Z and .tar.gz.

You =don’t need the tar program= to use Tar mode—Emacs reads the archives
directly. However, accessing compressed archives =requires the appropriate
uncompression program=.  A separate but similar Archive mode is used for =arc,
jar, lzh, zip, rar, 7z, and zoo archives=, as well as exe files that are
self-extracting executables

** backup&autosave
*** backup

Emacs 只会在第一次打开文件时创建 backup 文件，后续默认不会创建新的 backup 文件，
除非 kill 了 buffer 且重新打开这个文件。

At your option, Emacs can keep either =a single backup= for each file, or make =a
series of numbered backup files= for each file that you edit.

+ C-u C-x C-s: 下次保存文件时，将要保存的文件内容保存到 backup 文件。
+ C-u C-u C-x C-s：先将原始内容保存到 backup 文件，然后再保存当前 buffer；
+ C-u C-u C-u C-x C-s：和上面类似，但是下次保存文件时，先将原始内容保存到 back
  文件；

You can customize the variable =backup-directory-alist= to specify that files
=matching certain patterns= should be backed up =in specific directories=.

When Emacs makes a backup file, its name is normally constructed by =appending
‘~’= to the file name being edited; thus, the backup file for eval.c would be
eval.c~.

Emacs can also make =numbered backup files=. Numbered backup file names contain
‘.~’, the number, and another ‘~’ after the original file name. Thus, the backup
files of eval.c would be called =eval.c.~1~, eval.c.~2~=, and so on, all the way
through names like eval.c.~259~ and beyond.

The variable =version-control= determines whether to make single backup files or
mul- tiple numbered backup files.

To prevent excessive consumption of disk space, Emacs can =delete numbered backup
versions automatically=. Generally Emacs keeps the first few backups and the
latest few backups, =deleting any in between=.

*** autosave

Auto-Saving: Protection Against Disasters

From time to time, Emacs =automatically saves= each visited file in a separate
file, without altering the file you actually use. This is called =auto-saving=. It
prevents you from losing more than a limited amount of work if the =system
crashes=.

auto-saving 的文件一般保存在 autosave-dir 目录下，而不是原始文件目录或原始文件。

If you want auto-saving to be done in the visited file rather than in a separate
auto-save file, enable the global minor mode =auto-save-visited-mode=. In this
mode, auto-saving is identical to explicit saving.You can use the variable
=auto-save-visited-interval= to customize the interval between auto-save
operations in =auto-save-visited-mode=; by default it’s =five
seconds=. auto-save-interval and auto-save-timeout have =no effect= on auto-save-
visited-mode.

当 save the buffer 后，emacs 自动删除对应的 auto-save 文件。变量
auto-save-default 默认为 t，即默认开启 auto-save 模式。

Emacs =auto-saves periodically= based on =how many characters you have typed= since
the last auto-save. The variable auto-save-interval specifies how many
characters there are between auto-saves. By default, it is =300=.

Auto-saving also takes place when you stop typing for a while. By default, it
does this after =30 seconds= of idleness To change this interval, customize the
variable =auto-save-timeout=.

You can use the contents of an auto-save file to recover from a loss of data
with the command =M-x recover-file RET file RET=. This visits file and then (after
your confirmation) restores the contents from its auto-save file #file#.

If Emacs or the computer crashes, you can =recover all the files= you were editing
from their auto save files with the command =M-x recover-session=

总结：
1. backup 文件是第一次打开文件时创建，在编辑过程中默认不会在创建，除非 kill
   buffer 重新 open 文件。文件名以 ~ 结尾。可以指定保存多个 backup 文件，文件名
   以 =~N~= 结尾；
2. autosave 文件是编辑过程中自动创建的文件，用于预防断电等情况，文件名的开头和结
   尾均有 # ；

* Footnotes

[fn:1] 
